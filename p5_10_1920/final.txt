diff --git a/include/unistd.h b/include/unistd.h
index 9d13199..f93ce31 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -100,6 +100,10 @@ size_t	 confstr(int, char *, size_t);
 /* also declared in stdio.h */
 char	*cuserid(char *);	/* obsolete */
 #endif /* __CUSERID_DECLARED */
+
+/*mkadd*/
+int chrt(long deadline);
+
 int	 dup(int);
 int	 dup2(int, int);
 int	 execl(const char *, const char *, ...);
@@ -413,3 +417,5 @@ extern	 char *suboptarg;	/* getsubopt(3) external variable */
 
 __END_DECLS
 #endif /* !_UNISTD_H_ */
+
+
diff --git a/minix/commands/service/parse.c b/minix/commands/service/parse.c
index 478d2fa..90478f9 100644
--- a/minix/commands/service/parse.c
+++ b/minix/commands/service/parse.c
@@ -34,8 +34,8 @@
 #include "config.h"
 #include "proto.h"
 
-static int class_recurs;       /* Nesting level of class statements */
-#define MAX_CLASS_RECURS        100     /* Max nesting level for classes */
+static int class_recurs;		 /* Nesting level of class statements */
+#define MAX_CLASS_RECURS 100 /* Max nesting level for classes */
 
 #include "parse.h"
 
@@ -48,52 +48,52 @@ static void do_class(config_t *cpe, config_t *config, struct rs_config *rs_confi
 	if (class_recurs > MAX_CLASS_RECURS)
 	{
 		fatal(
-		"do_class: nesting level too high for class '%s' at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+				"do_class: nesting level too high for class '%s' at %s:%d",
+				cpe->word, cpe->file, cpe->line);
 	}
 	class_recurs++;
 
 	/* Process classes */
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_class: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_uid: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* Find entry for the class */
-		for (cp= config; cp; cp= cp->next)
+		for (cp = config; cp; cp = cp->next)
 		{
 			if (!(cp->flags & CFG_SUBLIST))
 			{
 				fatal("do_class: expected list at %s:%d",
-					cp->file, cp->line);
+							cp->file, cp->line);
 			}
-			cp1= cp->list;
+			cp1 = cp->list;
 			if ((cp1->flags & CFG_STRING) ||
-				(cp1->flags & CFG_SUBLIST))
+					(cp1->flags & CFG_SUBLIST))
 			{
 				fatal("do_class: expected word at %s:%d",
-					cp1->file, cp1->line);
+							cp1->file, cp1->line);
 			}
 
 			/* At this place we expect the word KW_SERVICE */
 			if (strcmp(cp1->word, KW_SERVICE) != 0)
 				fatal("do_class: exected word '%S' at %s:%d",
-					KW_SERVICE, cp1->file, cp1->line);
+							KW_SERVICE, cp1->file, cp1->line);
 
-			cp1= cp1->next;
+			cp1 = cp1->next;
 			if ((cp1->flags & CFG_STRING) ||
-				(cp1->flags & CFG_SUBLIST))
+					(cp1->flags & CFG_SUBLIST))
 			{
 				fatal("do_class: expected word at %s:%d",
-					cp1->file, cp1->line);
+							cp1->file, cp1->line);
 			}
 
 			/* At this place we expect the name of the service */
@@ -103,8 +103,8 @@ static void do_class(config_t *cpe, config_t *config, struct rs_config *rs_confi
 		if (cp == NULL)
 		{
 			fatal(
-			"do_class: no entry found for class '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
+					"do_class: no entry found for class '%s' at %s:%d",
+					cpe->word, cpe->file, cpe->line);
 		}
 		do_service(cp1->next, config, rs_config);
 	}
@@ -122,39 +122,40 @@ static void do_uid(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_uid: just one uid/login expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_uid: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_uid: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
-	pw= getpwnam(cpe->word);
+	pw = getpwnam(cpe->word);
 	if (pw != NULL)
-		uid= pw->pw_uid;
+		uid = pw->pw_uid;
 	else
 	{
-		if (!strncmp(cpe->word, KW_SELF, strlen(KW_SELF)+1))
+		if (!strncmp(cpe->word, KW_SELF, strlen(KW_SELF) + 1))
 		{
-			uid= getuid();	/* Real uid */
+			uid = getuid(); /* Real uid */
 		}
-		else {
-			uid= strtol(cpe->word, &check, 0);
+		else
+		{
+			uid = strtol(cpe->word, &check, 0);
 			if (check[0] != '\0')
 			{
 				fatal("do_uid: bad uid/login '%s' at %s:%d",
-					cpe->word, cpe->file, cpe->line);
+							cpe->word, cpe->file, cpe->line);
 			}
 		}
 	}
 
-	rs_start->rss_uid= uid;
+	rs_start->rss_uid = uid;
 }
 
 static void do_sigmgr(config_t *cpe, struct rs_start *rs_start)
@@ -166,32 +167,34 @@ static void do_sigmgr(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_sigmgr: just one sigmgr value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_sigmgr: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_sigmgr: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 
-	if(!strcmp(cpe->word, "SELF")) {
+	if (!strcmp(cpe->word, "SELF"))
+	{
 		sigmgr_ep = SELF;
 	}
-	else {
-		if((r = minix_rs_lookup(cpe->word, &sigmgr_ep))) {
+	else
+	{
+		if ((r = minix_rs_lookup(cpe->word, &sigmgr_ep)))
+		{
 			fatal("do_sigmgr: unknown sigmgr %s at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
 	}
 
-	rs_start->rss_sigmgr= sigmgr_ep;
+	rs_start->rss_sigmgr = sigmgr_ep;
 }
 
 static void do_type(config_t *cpe, struct rs_config *rs_config)
@@ -199,30 +202,29 @@ static void do_type(config_t *cpe, struct rs_config *rs_config)
 	if (cpe->next != NULL)
 	{
 		fatal("do_type: just one type value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_type: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if ((cpe->flags & CFG_STRING))
 	{
 		fatal("do_type: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 
-	if(rs_config->type)
+	if (rs_config->type)
 		fatal("do_type: another type at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 
-	if(!strcmp(cpe->word, KW_NET))
+	if (!strcmp(cpe->word, KW_NET))
 		rs_config->type = KW_NET;
 	else
 		fatal("do_type: odd type at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 }
 
 static void do_descr(config_t *cpe, struct rs_config *rs_config)
@@ -230,24 +232,23 @@ static void do_descr(config_t *cpe, struct rs_config *rs_config)
 	if (cpe->next != NULL)
 	{
 		fatal("do_descr: just one description expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_descr: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (!(cpe->flags & CFG_STRING))
 	{
 		fatal("do_descr: expected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 
-	if(rs_config->descr)
+	if (rs_config->descr)
 		fatal("do_descr: another descr at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	rs_config->descr = cpe->word;
 }
 
@@ -260,32 +261,34 @@ static void do_scheduler(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_scheduler: just one scheduler value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_scheduler: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_scheduler: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 
-	if(!strcmp(cpe->word, "KERNEL")) {
+	if (!strcmp(cpe->word, "KERNEL"))
+	{
 		scheduler_ep = KERNEL;
 	}
-	else {
-		if((r = minix_rs_lookup(cpe->word, &scheduler_ep))) {
+	else
+	{
+		if ((r = minix_rs_lookup(cpe->word, &scheduler_ep)))
+		{
 			fatal("do_scheduler: unknown scheduler %s at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
 	}
 
-	rs_start->rss_scheduler= scheduler_ep;
+	rs_start->rss_scheduler = scheduler_ep;
 }
 
 static void do_priority(config_t *cpe, struct rs_start *rs_start)
@@ -297,33 +300,32 @@ static void do_priority(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_priority: just one priority value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_priority: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_priority: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
-	priority_val= strtol(cpe->word, &check, 0);
+	priority_val = strtol(cpe->word, &check, 0);
 	if (check[0] != '\0')
 	{
 		fatal("do_priority: bad priority value '%s' at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+					cpe->word, cpe->file, cpe->line);
 	}
 
 	if (priority_val < 0 || priority_val >= NR_SCHED_QUEUES)
 	{
 		fatal("do_priority: priority %d out of range at %s:%d",
-			priority_val, cpe->file, cpe->line);
+					priority_val, cpe->file, cpe->line);
 	}
-	rs_start->rss_priority= priority_val;
+	rs_start->rss_priority = priority_val;
 }
 
 static void do_quantum(config_t *cpe, struct rs_start *rs_start)
@@ -335,33 +337,32 @@ static void do_quantum(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_quantum: just one quantum value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_quantum: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_quantum: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
-	quantum_val= strtol(cpe->word, &check, 0);
+	quantum_val = strtol(cpe->word, &check, 0);
 	if (check[0] != '\0')
 	{
 		fatal("do_quantum: bad quantum value '%s' at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+					cpe->word, cpe->file, cpe->line);
 	}
 
 	if (quantum_val <= 0)
 	{
 		fatal("do_quantum: quantum %d out of range at %s:%d",
-			quantum_val, cpe->file, cpe->line);
+					quantum_val, cpe->file, cpe->line);
 	}
-	rs_start->rss_quantum= quantum_val;
+	rs_start->rss_quantum = quantum_val;
 }
 
 static void do_cpu(config_t *cpe, struct rs_start *rs_start)
@@ -373,33 +374,32 @@ static void do_cpu(config_t *cpe, struct rs_start *rs_start)
 	if (cpe->next != NULL)
 	{
 		fatal("do_cpu: just one value expected at %s:%d",
-			cpe->file, cpe->line);
-	}	
-	
+					cpe->file, cpe->line);
+	}
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_cpu: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_cpu: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
-	cpu= strtol(cpe->word, &check, 0);
+	cpu = strtol(cpe->word, &check, 0);
 	if (check[0] != '\0')
 	{
 		fatal("do_cpu: bad value '%s' at %s:%d",
-			cpe->word, cpe->file, cpe->line);
+					cpe->word, cpe->file, cpe->line);
 	}
 
 	if (cpu < 0)
 	{
 		fatal("do_cpu: %d out of range at %s:%d",
-			cpu, cpe->file, cpe->line);
+					cpu, cpe->file, cpe->line);
 	}
-	rs_start->rss_cpu= cpu;
+	rs_start->rss_cpu = cpu;
 }
 
 static void do_irq(config_t *cpe, struct rs_start *rs_start)
@@ -410,48 +410,52 @@ static void do_irq(config_t *cpe, struct rs_start *rs_start)
 
 	/* Process a list of IRQs */
 	first = TRUE;
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_irq: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_irq: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* No IRQ allowed? (default) */
-		if(!strcmp(cpe->word, KW_NONE)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_NONE))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_irq: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			break;
 		}
 
 		/* All IRQs are allowed? */
-		if(!strcmp(cpe->word, KW_ALL)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_ALL))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_irq: %s keyword not allowed in list",
-				KW_ALL);
+							KW_ALL);
 			}
 			rs_start->rss_nr_irq = RSS_IO_ALL;
 			break;
 		}
 
 		/* Set single IRQs as specified in the configuration. */
-		irq= strtoul(cpe->word, &check, 0);
+		irq = strtoul(cpe->word, &check, 0);
 		if (check[0] != '\0')
 		{
 			fatal("do_irq: bad irq '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
 		if (rs_start->rss_nr_irq >= RSS_NR_IRQ)
 			fatal("do_irq: too many IRQs (max %d)", RSS_NR_IRQ);
-		rs_start->rss_irq[rs_start->rss_nr_irq]= irq;
+		rs_start->rss_irq[rs_start->rss_nr_irq] = irq;
 		rs_start->rss_nr_irq++;
 		first = FALSE;
 	}
@@ -465,55 +469,59 @@ static void do_io(config_t *cpe, struct rs_start *rs_start)
 
 	/* Process a list of I/O ranges */
 	first = TRUE;
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_io: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_io: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* No range allowed? (default) */
-		if(!strcmp(cpe->word, KW_NONE)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_NONE))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_io: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			break;
 		}
 
 		/* All ranges are allowed? */
-		if(!strcmp(cpe->word, KW_ALL)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_ALL))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_io: %s keyword not allowed in list",
-				KW_ALL);
+							KW_ALL);
 			}
 			rs_start->rss_nr_io = RSS_IO_ALL;
 			break;
 		}
 
 		/* Set single ranges as specified in the configuration. */
-		base= strtoul(cpe->word, &check, 0x10);
-		len= 1;
+		base = strtoul(cpe->word, &check, 0x10);
+		len = 1;
 		if (check[0] == ':')
 		{
-			len= strtoul(check+1, &check, 0x10);
+			len = strtoul(check + 1, &check, 0x10);
 		}
 		if (check[0] != '\0')
 		{
 			fatal("do_io: bad I/O range '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
 
 		if (rs_start->rss_nr_io >= RSS_NR_IO)
 			fatal("do_io: too many I/O ranges (max %d)", RSS_NR_IO);
-		rs_start->rss_io[rs_start->rss_nr_io].base= base;
-		rs_start->rss_io[rs_start->rss_nr_io].len= len;
+		rs_start->rss_io[rs_start->rss_nr_io].base = base;
+		rs_start->rss_io[rs_start->rss_nr_io].len = len;
 		rs_start->rss_nr_io++;
 		first = FALSE;
 	}
@@ -525,48 +533,55 @@ static void do_pci_device(config_t *cpe, struct rs_start *rs_start)
 	char *check, *check2;
 
 	/* Process a list of PCI device IDs */
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_pci_device: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_pci_device: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
-		vid= strtoul(cpe->word, &check, 0x10);
-		if (check[0] != ':' && /* LEGACY: */ check[0] != '/') {
+		vid = strtoul(cpe->word, &check, 0x10);
+		if (check[0] != ':' && /* LEGACY: */ check[0] != '/')
+		{
 			fatal("do_pci_device: bad ID '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
-		did= strtoul(check+1, &check, 0x10);
-		if (check[0] == '/') {
-			sub_vid= strtoul(check+1, &check, 0x10);
+		did = strtoul(check + 1, &check, 0x10);
+		if (check[0] == '/')
+		{
+			sub_vid = strtoul(check + 1, &check, 0x10);
 			if (check[0] == ':')
-				sub_did= strtoul(check+1, &check2, 0x10);
-			if (check[0] != ':' || check2[0] != '\0') {
+				sub_did = strtoul(check + 1, &check2, 0x10);
+			if (check[0] != ':' || check2[0] != '\0')
+			{
 				fatal("do_pci_device: bad ID '%s' at %s:%d",
-					cpe->word, cpe->file, cpe->line);
+							cpe->word, cpe->file, cpe->line);
 			}
-		} else if (check[0] != '\0') {
+		}
+		else if (check[0] != '\0')
+		{
 			fatal("do_pci_device: bad ID '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
-		} else {
+						cpe->word, cpe->file, cpe->line);
+		}
+		else
+		{
 			sub_vid = NO_SUB_VID;
 			sub_did = NO_SUB_DID;
 		}
 		if (rs_start->rss_nr_pci_id >= RS_NR_PCI_DEVICE)
 		{
 			fatal("do_pci_device: too many device IDs (max %d)",
-				RS_NR_PCI_DEVICE);
+						RS_NR_PCI_DEVICE);
 		}
-		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].vid= vid;
-		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].did= did;
-		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].sub_vid= sub_vid;
-		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].sub_did= sub_did;
+		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].vid = vid;
+		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].did = did;
+		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].sub_vid = sub_vid;
+		rs_start->rss_pci_id[rs_start->rss_nr_pci_id].sub_did = sub_did;
 		rs_start->rss_nr_pci_id++;
 	}
 }
@@ -578,48 +593,48 @@ static void do_pci_class(config_t *cpe, struct rs_start *rs_start)
 	char *check;
 
 	/* Process a list of PCI device class IDs */
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_pci_device: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_pci_device: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
-		baseclass= strtoul(cpe->word, &check, 0x10);
-		subclass= 0;
-		interface= 0;
-		mask= 0xff0000;
+		baseclass = strtoul(cpe->word, &check, 0x10);
+		subclass = 0;
+		interface = 0;
+		mask = 0xff0000;
 		if (check[0] == '/')
 		{
-			subclass= strtoul(check+1, &check, 0x10);
-			mask= 0xffff00;
+			subclass = strtoul(check + 1, &check, 0x10);
+			mask = 0xffff00;
 			if (check[0] == '/')
 			{
-				interface= strtoul(check+1, &check, 0x10);
-				mask= 0xffffff;
+				interface = strtoul(check + 1, &check, 0x10);
+				mask = 0xffffff;
 			}
 		}
 
 		if (check[0] != '\0')
 		{
 			fatal("do_pci_class: bad class ID '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
+						cpe->word, cpe->file, cpe->line);
 		}
-		class_id= (baseclass << 16) | (subclass << 8) | interface;
+		class_id = (baseclass << 16) | (subclass << 8) | interface;
 		if (rs_start->rss_nr_pci_class >= RS_NR_PCI_CLASS)
 		{
 			fatal("do_pci_class: too many class IDs (max %d)",
-				RS_NR_PCI_CLASS);
+						RS_NR_PCI_CLASS);
 		}
-		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].pciclass=
-			class_id;
-		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].mask= mask;
+		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].pciclass =
+				class_id;
+		rs_start->rss_pci_class[rs_start->rss_nr_pci_class].mask = mask;
 		rs_start->rss_nr_pci_class++;
 	}
 }
@@ -627,17 +642,17 @@ static void do_pci_class(config_t *cpe, struct rs_start *rs_start)
 static void do_pci(config_t *cpe, struct rs_start *rs_start)
 {
 	if (cpe == NULL)
-		return;	/* Empty PCI statement */
+		return; /* Empty PCI statement */
 
 	if (cpe->flags & CFG_SUBLIST)
 	{
 		fatal("do_pci: unexpected sublist at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->flags & CFG_STRING)
 	{
 		fatal("do_pci: unexpected string at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 
 	if (strcmp(cpe->word, KW_DEVICE) == 0)
@@ -651,7 +666,7 @@ static void do_pci(config_t *cpe, struct rs_start *rs_start)
 		return;
 	}
 	fatal("do_pci: unexpected word '%s' at %s:%d",
-		cpe->word, cpe->file, cpe->line);
+				cpe->word, cpe->file, cpe->line);
 }
 
 static void do_ipc(config_t *cpe, struct rs_start *rs_start)
@@ -663,48 +678,50 @@ static void do_ipc(config_t *cpe, struct rs_start *rs_start)
 	size_t listsize, wordlen;
 	int first;
 
-	list= NULL;
-	listsize= 1;
-	list= malloc(listsize);
+	list = NULL;
+	listsize = 1;
+	list = malloc(listsize);
 	if (list == NULL)
 		fatal("do_ipc: unable to malloc %d bytes", listsize);
-	list[0]= '\0';
+	list[0] = '\0';
 
 	/* Process a list of process names that are allowed to be
 	 * contacted
 	 */
 	first = TRUE;
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_ipc: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_ipc: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		word = cpe->word;
 
 		/* All (system) ipc targets are allowed? */
-		if(!strcmp(word, KW_ALL) || !strcmp(word, KW_ALL_SYS)) {
-			if(!first || cpe->next) {
+		if (!strcmp(word, KW_ALL) || !strcmp(word, KW_ALL_SYS))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_ipc: %s keyword not allowed in list",
-				word);
+							word);
 			}
 			word = !strcmp(word, KW_ALL) ? word_all : word_all_sys;
 		}
 
-		wordlen= strlen(word);
+		wordlen = strlen(word);
 
 		listsize += 1 + wordlen;
-		list= realloc(list, listsize);
+		list = realloc(list, listsize);
 		if (list == NULL)
 		{
 			fatal("do_ipc: unable to realloc %d bytes",
-				listsize);
+						listsize);
 		}
 		strcat(list, " ");
 		strcat(list, word);
@@ -716,44 +733,43 @@ static void do_ipc(config_t *cpe, struct rs_start *rs_start)
 
 	if (rs_start->rss_ipc)
 		fatal("do_ipc: req_ipc is set");
-        rs_start->rss_ipc = list+1;
-	rs_start->rss_ipclen= strlen(rs_start->rss_ipc);
+	rs_start->rss_ipc = list + 1;
+	rs_start->rss_ipclen = strlen(rs_start->rss_ipc);
 }
 
-
 struct
 {
 	char *label;
 	int call_nr;
 } vm_table[] =
-{
-	{ "EXIT",		VM_EXIT },
-	{ "FORK",		VM_FORK },
-	{ "EXEC_NEWMEM",	VM_EXEC_NEWMEM },
-	{ "PUSH_SIG",		0 },
-	{ "WILLEXIT",		VM_WILLEXIT },
-	{ "ADDDMA",		VM_ADDDMA },
-	{ "DELDMA",		VM_DELDMA },
-	{ "GETDMA",		VM_GETDMA },
-	{ "REMAP",		VM_REMAP },
-	{ "REMAP_RO",		VM_REMAP_RO },
-	{ "SHM_UNMAP",		VM_SHM_UNMAP },
-	{ "GETPHYS",		VM_GETPHYS },
-	{ "GETREF",		VM_GETREF },
-	{ "RS_SET_PRIV",	VM_RS_SET_PRIV },
-	{ "QUERY_EXIT",		VM_QUERY_EXIT },
-	{ "WATCH_EXIT",		VM_WATCH_EXIT },
-	{ "NOTIFY_SIG",		VM_NOTIFY_SIG },
-	{ "INFO",		VM_INFO },
-	{ "RS_UPDATE",		VM_RS_UPDATE },
-	{ "RS_MEMCTL",		VM_RS_MEMCTL },
-	{ "PROCCTL",		VM_PROCCTL },
-	{ "MAPCACHEPAGE",	VM_MAPCACHEPAGE },
-	{ "SETCACHEPAGE",	VM_SETCACHEPAGE },
-	{ "CLEARCACHE",		VM_CLEARCACHE },
-	{ "VFS_MMAP",		VM_VFS_MMAP },
-	{ "VFS_REPLY",		VM_VFS_REPLY },
-	{ NULL,			0 },
+		{
+				{"EXIT", VM_EXIT},
+				{"FORK", VM_FORK},
+				{"EXEC_NEWMEM", VM_EXEC_NEWMEM},
+				{"PUSH_SIG", 0},
+				{"WILLEXIT", VM_WILLEXIT},
+				{"ADDDMA", VM_ADDDMA},
+				{"DELDMA", VM_DELDMA},
+				{"GETDMA", VM_GETDMA},
+				{"REMAP", VM_REMAP},
+				{"REMAP_RO", VM_REMAP_RO},
+				{"SHM_UNMAP", VM_SHM_UNMAP},
+				{"GETPHYS", VM_GETPHYS},
+				{"GETREF", VM_GETREF},
+				{"RS_SET_PRIV", VM_RS_SET_PRIV},
+				{"QUERY_EXIT", VM_QUERY_EXIT},
+				{"WATCH_EXIT", VM_WATCH_EXIT},
+				{"NOTIFY_SIG", VM_NOTIFY_SIG},
+				{"INFO", VM_INFO},
+				{"RS_UPDATE", VM_RS_UPDATE},
+				{"RS_MEMCTL", VM_RS_MEMCTL},
+				{"PROCCTL", VM_PROCCTL},
+				{"MAPCACHEPAGE", VM_MAPCACHEPAGE},
+				{"SETCACHEPAGE", VM_SETCACHEPAGE},
+				{"CLEARCACHE", VM_CLEARCACHE},
+				{"VFS_MMAP", VM_VFS_MMAP},
+				{"VFS_REPLY", VM_VFS_REPLY},
+				{NULL, 0},
 };
 
 static void do_vm(config_t *cpe, struct rs_start *rs_start)
@@ -766,38 +782,44 @@ static void do_vm(config_t *cpe, struct rs_start *rs_start)
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_vm: unexpected sublist at %s:%d",
-			      cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_vm: unexpected string at %s:%d",
-			      cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* Only basic calls allowed? (default). */
-		if(!strcmp(cpe->word, KW_BASIC)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_BASIC))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_vm: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			break;
 		}
 
 		/* No calls allowed? */
-		if(!strcmp(cpe->word, KW_NONE)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_NONE))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_vm: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			rs_start->rss_flags &= ~RSS_VM_BASIC_CALLS;
 			break;
 		}
 
 		/* All calls are allowed? */
-		if(!strcmp(cpe->word, KW_ALL)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_ALL))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_vm: %s keyword not allowed in list",
-				KW_ALL);
+							KW_ALL);
 			}
 			for (i = 0; i < NR_VM_CALLS; i++)
 				SET_BIT(rs_start->rss_vm, i);
@@ -808,12 +830,15 @@ static void do_vm(config_t *cpe, struct rs_start *rs_start)
 		for (i = 0; vm_table[i].label != NULL; i++)
 			if (!strcmp(cpe->word, vm_table[i].label))
 				break;
-		if (vm_table[i].label == NULL) {
+		if (vm_table[i].label == NULL)
+		{
 			warning("do_vm: ignoring unknown call '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
-		} else if(vm_table[i].call_nr) {
+							cpe->word, cpe->file, cpe->line);
+		}
+		else if (vm_table[i].call_nr)
+		{
 			SET_BIT(rs_start->rss_vm,
-				vm_table[i].call_nr - VM_RQ_BASE);
+							vm_table[i].call_nr - VM_RQ_BASE);
 		}
 
 		first = FALSE;
@@ -824,30 +849,30 @@ struct
 {
 	char *label;
 	int call_nr;
-} system_tab[]=
-{
-	{ "PRIVCTL",		SYS_PRIVCTL },
-	{ "TRACE",		SYS_TRACE },
-	{ "KILL",		SYS_KILL },
-	{ "UMAP",		SYS_UMAP },
-	{ "VIRCOPY",		SYS_VIRCOPY },
-	{ "PHYSCOPY",		SYS_PHYSCOPY },
-	{ "UMAP_REMOTE",	SYS_UMAP_REMOTE },
-	{ "VUMAP",		SYS_VUMAP },
-	{ "IRQCTL",		SYS_IRQCTL },
-	{ "INT86",		SYS_INT86 },
-	{ "DEVIO",		SYS_DEVIO },
-	{ "SDEVIO",		SYS_SDEVIO },
-	{ "VDEVIO",		SYS_VDEVIO },
-	{ "ABORT",		SYS_ABORT },
-	{ "IOPENABLE",		SYS_IOPENABLE },
-	{ "READBIOS",		SYS_READBIOS },
-	{ "STIME",		SYS_STIME },
-	{ "VMCTL",		SYS_VMCTL },
-	{ "MEMSET",		SYS_MEMSET },
-	{ "PADCONF",		SYS_PADCONF },
-	{ NULL,		0 }
-};
+} system_tab[] =
+		{
+				{"PRIVCTL", SYS_PRIVCTL},
+				{"CHRT", SYS_CHRT},
+				{"TRACE", SYS_TRACE},
+				{"KILL", SYS_KILL},
+				{"UMAP", SYS_UMAP},
+				{"VIRCOPY", SYS_VIRCOPY},
+				{"PHYSCOPY", SYS_PHYSCOPY},
+				{"UMAP_REMOTE", SYS_UMAP_REMOTE},
+				{"VUMAP", SYS_VUMAP},
+				{"IRQCTL", SYS_IRQCTL},
+				{"INT86", SYS_INT86},
+				{"DEVIO", SYS_DEVIO},
+				{"SDEVIO", SYS_SDEVIO},
+				{"VDEVIO", SYS_VDEVIO},
+				{"ABORT", SYS_ABORT},
+				{"IOPENABLE", SYS_IOPENABLE},
+				{"READBIOS", SYS_READBIOS},
+				{"STIME", SYS_STIME},
+				{"VMCTL", SYS_VMCTL},
+				{"MEMSET", SYS_MEMSET},
+				{"PADCONF", SYS_PADCONF},
+				{NULL, 0}};
 
 static void do_system(config_t *cpe, struct rs_start *rs_start)
 {
@@ -855,43 +880,49 @@ static void do_system(config_t *cpe, struct rs_start *rs_start)
 
 	/* Process a list of 'system' calls that are allowed */
 	first = TRUE;
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_system: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_system: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* Only basic calls allowed? (default). */
-		if(!strcmp(cpe->word, KW_BASIC)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_BASIC))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_system: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			break;
 		}
 
 		/* No calls allowed? */
-		if(!strcmp(cpe->word, KW_NONE)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_NONE))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_system: %s keyword not allowed in list",
-				KW_NONE);
+							KW_NONE);
 			}
 			rs_start->rss_flags &= ~RSS_SYS_BASIC_CALLS;
 			break;
 		}
 
 		/* All calls are allowed? */
-		if(!strcmp(cpe->word, KW_ALL)) {
-			if(!first || cpe->next) {
+		if (!strcmp(cpe->word, KW_ALL))
+		{
+			if (!first || cpe->next)
+			{
 				fatal("do_system: %s keyword not allowed in list",
-				KW_ALL);
+							KW_ALL);
 			}
 			for (i = 0; i < NR_SYS_CALLS; i++)
 				SET_BIT(rs_start->rss_system, i);
@@ -902,12 +933,15 @@ static void do_system(config_t *cpe, struct rs_start *rs_start)
 		for (i = 0; system_tab[i].label != NULL; i++)
 			if (!strcmp(cpe->word, system_tab[i].label))
 				break;
-		if (system_tab[i].label == NULL) {
-		   warning("do_system: ignoring unknown call '%s' at %s:%d",
-				cpe->word, cpe->file, cpe->line);
-		} else {
+		if (system_tab[i].label == NULL)
+		{
+			warning("do_system: ignoring unknown call '%s' at %s:%d",
+							cpe->word, cpe->file, cpe->line);
+		}
+		else
+		{
 			SET_BIT(rs_start->rss_system,
-				system_tab[i].call_nr - KERNEL_CALL);
+							system_tab[i].call_nr - KERNEL_CALL);
 		}
 		first = FALSE;
 	}
@@ -918,26 +952,26 @@ static void do_control(config_t *cpe, struct rs_start *rs_start)
 	int nr_control = 0;
 
 	/* Process a list of 'control' labels. */
-	for (; cpe; cpe= cpe->next)
+	for (; cpe; cpe = cpe->next)
 	{
 		if (cpe->flags & CFG_SUBLIST)
 		{
 			fatal("do_control: unexpected sublist at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (cpe->flags & CFG_STRING)
 		{
 			fatal("do_control: unexpected string at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 		if (nr_control >= RS_NR_CONTROL)
 		{
 			fatal(
-			"do_control: RS_NR_CONTROL is too small (%d needed)",
-				nr_control+1);
+					"do_control: RS_NR_CONTROL is too small (%d needed)",
+					nr_control + 1);
 		}
 
-		rs_start->rss_control[nr_control].l_addr = (char*) cpe->word;
+		rs_start->rss_control[nr_control].l_addr = (char *)cpe->word;
 		rs_start->rss_control[nr_control].l_len = strlen(cpe->word);
 		rs_start->rss_nr_control = ++nr_control;
 	}
@@ -954,29 +988,29 @@ static void do_service(config_t *cpe, config_t *config, struct rs_config *rs_con
 	if (!(cpe->flags & CFG_SUBLIST))
 	{
 		fatal("do_service: expected list at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
 	if (cpe->next != NULL)
 	{
-		cpe= cpe->next;
+		cpe = cpe->next;
 		fatal("do_service: expected end of list at %s:%d",
-			cpe->file, cpe->line);
+					cpe->file, cpe->line);
 	}
-	cpe= cpe->list;
+	cpe = cpe->list;
 
 	/* Process the list */
-	for (cp= cpe; cp; cp= cp->next)
+	for (cp = cpe; cp; cp = cp->next)
 	{
 		if (!(cp->flags & CFG_SUBLIST))
 		{
 			fatal("do_service: expected list at %s:%d",
-				cp->file, cp->line);
+						cp->file, cp->line);
 		}
-		cpe= cp->list;
+		cpe = cp->list;
 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
 		{
 			fatal("do_service: expected word at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		if (strcmp(cpe->word, KW_CLASS) == 0)
@@ -1068,50 +1102,51 @@ static const char *do_config(const char *label, char *filename, struct rs_config
 	struct passwd *pw;
 	struct rs_start *rs_start = &rs_config->rs_start;
 
-	if(!(config= config_read(filename, 0, NULL)))
+	if (!(config = config_read(filename, 0, NULL)))
 		return NULL; /* config file read failed. */
 
 	/* Set clean rs_start defaults. */
 	memset(rs_config, 0, sizeof(*rs_config));
-	if(!(pw= getpwnam(SERVICE_LOGIN)))
+	if (!(pw = getpwnam(SERVICE_LOGIN)))
 		fatal("no passwd file entry for '%s'", SERVICE_LOGIN);
-	rs_start->rss_uid= pw->pw_uid;
-	rs_start->rss_sigmgr= DSRV_SM;
-	rs_start->rss_scheduler= DSRV_SCH;
-	rs_start->rss_priority= DSRV_Q;
-	rs_start->rss_quantum= DSRV_QT;
+	rs_start->rss_uid = pw->pw_uid;
+	rs_start->rss_sigmgr = DSRV_SM;
+	rs_start->rss_scheduler = DSRV_SCH;
+	rs_start->rss_priority = DSRV_Q;
+	rs_start->rss_quantum = DSRV_QT;
 	rs_start->rss_cpu = DSRV_CPU;
 	rs_start->rss_flags = RSS_VM_BASIC_CALLS | RSS_SYS_BASIC_CALLS;
 
 	/* Find an entry for our service */
-	for (cp= config; cp; cp= cp->next)
+	for (cp = config; cp; cp = cp->next)
 	{
 		if (!(cp->flags & CFG_SUBLIST))
 		{
 			fatal("do_config: expected list at %s:%d",
-				cp->file, cp->line);
+						cp->file, cp->line);
 		}
-		cpe= cp->list;
+		cpe = cp->list;
 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
 		{
 			fatal("do_config: expected word at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* At this place we expect the word KW_SERVICE */
 		if (strcmp(cpe->word, KW_SERVICE) != 0)
 			fatal("do_config: exected word '%S' at %s:%d",
-				KW_SERVICE, cpe->file, cpe->line);
+						KW_SERVICE, cpe->file, cpe->line);
 
-		cpe= cpe->next;
+		cpe = cpe->next;
 		if ((cpe->flags & CFG_STRING) || (cpe->flags & CFG_SUBLIST))
 		{
 			fatal("do_config: expected word at %s:%d",
-				cpe->file, cpe->line);
+						cpe->file, cpe->line);
 		}
 
 		/* At this place we expect the name of the service. */
-		if (!label || strcmp(cpe->word, label) == 0) {
+		if (!label || strcmp(cpe->word, label) == 0)
+		{
 			label = cpe->word;
 			break;
 		}
@@ -1119,19 +1154,20 @@ static const char *do_config(const char *label, char *filename, struct rs_config
 	if (cp == NULL)
 	{
 		fprintf(stderr, "service: service '%s' not found in '%s'\n",
-			label, filename);
+						label, filename);
 		exit(1);
 	}
 
-	cpe= cpe->next;
+	cpe = cpe->next;
 
 	do_service(cpe, config, rs_config);
 
 	{
 		char *default_ipc = RSS_IPC_ALL_SYS;
-		if(!rs_start->rss_ipc) {
-		      rs_start->rss_ipc= default_ipc;
-		      rs_start->rss_ipclen= strlen(default_ipc);
+		if (!rs_start->rss_ipc)
+		{
+			rs_start->rss_ipc = default_ipc;
+			rs_start->rss_ipclen = strlen(default_ipc);
 		}
 	}
 
@@ -1141,34 +1177,38 @@ static const char *do_config(const char *label, char *filename, struct rs_config
 
 /* returns failure */
 const char *parse_config(char *progname, int custom_config, char *req_config,
-	struct rs_config *rs_config)
+												 struct rs_config *rs_config)
 {
-        char *specificconfig, *specific_pkg_config;
+	char *specificconfig, *specific_pkg_config;
 	const char *l;
 
 	/* Config file specified? */
-        if(custom_config)
-          return do_config(progname, req_config, rs_config);
+	if (custom_config)
+		return do_config(progname, req_config, rs_config);
 
 	/* No specific config file. */
-        if(asprintf(&specificconfig, "%s/%s", _PATH_SYSTEM_CONF_DIR,
-              progname) < 0) {
-              errx(1, "no memory");
-        }
+	if (asprintf(&specificconfig, "%s/%s", _PATH_SYSTEM_CONF_DIR,
+							 progname) < 0)
+	{
+		errx(1, "no memory");
+	}
 
-        if(asprintf(&specific_pkg_config, "%s/%s", _PATH_SYSTEM_CONF_PKG_DIR,
-              progname) < 0) {
-              errx(1, "no memory");
-        }
+	if (asprintf(&specific_pkg_config, "%s/%s", _PATH_SYSTEM_CONF_PKG_DIR,
+							 progname) < 0)
+	{
+		errx(1, "no memory");
+	}
 
-        /* Try specific config filename first, in base system
+	/* Try specific config filename first, in base system
 	 * and package locations, * and only if it fails, the global
 	 * system one.
          */
-	if((l=do_config(progname, specific_pkg_config, rs_config))) return l;
-	if((l=do_config(progname, specificconfig, rs_config))) return l;
-	if((l=do_config(progname, req_config, rs_config))) return l;
+	if ((l = do_config(progname, specific_pkg_config, rs_config)))
+		return l;
+	if ((l = do_config(progname, specificconfig, rs_config)))
+		return l;
+	if ((l = do_config(progname, req_config, rs_config)))
+		return l;
 
 	return NULL;
 }
-
diff --git a/minix/include/minix/callnr.h b/minix/include/minix/callnr.h
index 6030687..064933b 100644
--- a/minix/include/minix/callnr.h
+++ b/minix/include/minix/callnr.h
@@ -58,8 +58,9 @@
 #define PM_GETEPINFO		(PM_BASE + 45)
 #define PM_GETPROCNR		(PM_BASE + 46)
 #define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_CHRT		(PM_BASE + 48)
+#define NR_PM_CALLS		49	/* highest number from base plus one */
 
-#define NR_PM_CALLS		48	/* highest number from base plus one */
 
 /*===========================================================================*
  *				Calls to VFS				     *
diff --git a/minix/include/minix/com.h b/minix/include/minix/com.h
index 637f77c..0dec532 100644
--- a/minix/include/minix/com.h
+++ b/minix/include/minix/com.h
@@ -33,44 +33,44 @@
  */
 
 #ifndef _MINIX_COM_H
-#define _MINIX_COM_H 
+#define _MINIX_COM_H
 
 /*===========================================================================*
  *            	Process numbers of processes in the system image	     *
  *===========================================================================*/
 
 /* Kernel tasks. These all run in the same address space. */
-#define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
-#define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
-#define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
-#define SYSTEM  ((endpoint_t) -2) /* request system functionality */
-#define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
-#define HARDWARE     KERNEL	/* for hardware interrupt handlers */
+#define ASYNCM ((endpoint_t)-5) /* notifies about finished async sends */
+#define IDLE ((endpoint_t)-4)		/* runs when no one else can run */
+#define CLOCK ((endpoint_t)-3)	/* alarms and other clock functions */
+#define SYSTEM ((endpoint_t)-2) /* request system functionality */
+#define KERNEL ((endpoint_t)-1) /* pseudo-process for IPC and scheduling */
+#define HARDWARE KERNEL					/* for hardware interrupt handlers */
 
 /* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
-#define MAX_NR_TASKS	1023
-#define NR_TASKS	  5 
+#define MAX_NR_TASKS 1023
+#define NR_TASKS 5
 
 /* User-space processes, that is, device drivers, servers, and INIT. */
-#define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
-#define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
-#define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
-#define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
-#define SCHED_PROC_NR ((endpoint_t) 4)	/* scheduler */
-#define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
-#define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
-#define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
-#define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
-#define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
-#define LAST_SPECIAL_PROC_NR	10	/* An untyped version for
-                                           computation in macros.*/
-#define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
-                                                        -- goes multiuser */
-#define NR_BOOT_MODULES (INIT_PROC_NR+1)
+#define PM_PROC_NR ((endpoint_t)0)											/* process manager */
+#define VFS_PROC_NR ((endpoint_t)1)											/* file system */
+#define RS_PROC_NR ((endpoint_t)2)											/* reincarnation server */
+#define MEM_PROC_NR ((endpoint_t)3)											/* memory driver (RAM disk, null, etc.) */
+#define SCHED_PROC_NR ((endpoint_t)4)										/* scheduler */
+#define TTY_PROC_NR ((endpoint_t)5)											/* terminal (TTY) driver */
+#define DS_PROC_NR ((endpoint_t)6)											/* data store server */
+#define MFS_PROC_NR ((endpoint_t)7)											/* minix root filesystem */
+#define VM_PROC_NR ((endpoint_t)8)											/* memory server */
+#define PFS_PROC_NR ((endpoint_t)9)											/* pipe filesystem */
+#define LAST_SPECIAL_PROC_NR 10													/* An untyped version for \
+																																 computation in macros.*/
+#define INIT_PROC_NR ((endpoint_t)LAST_SPECIAL_PROC_NR) /* init \
+																											-- goes multiuser */
+#define NR_BOOT_MODULES (INIT_PROC_NR + 1)
 
 /* Root system process and root user process. */
-#define ROOT_SYS_PROC_NR  RS_PROC_NR
-#define ROOT_USR_PROC_NR  INIT_PROC_NR
+#define ROOT_SYS_PROC_NR RS_PROC_NR
+#define ROOT_USR_PROC_NR INIT_PROC_NR
 
 /*===========================================================================*
  *                	   Kernel notification types                         *
@@ -82,112 +82,112 @@
  * blocking notifications are delivered. The lowest numbers go first. The
  * offset are used for the per-process notification bit maps. 
  */
-#define NOTIFY_MESSAGE		  0x1000
+#define NOTIFY_MESSAGE 0x1000
 /* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
 #define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
-#define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
+#define is_notify(a) ((unsigned)((a)-NOTIFY_MESSAGE) < 0x100)
 #define is_ipc_asynch(ipc_status) \
-    (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
+	(is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
 
 /*===========================================================================*
  *                Messages for BUS controller drivers 			     *
  *===========================================================================*/
-#define BUSC_RQ_BASE	0x300	/* base for request types */
-#define BUSC_RS_BASE	0x380	/* base for response types */
-
-#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
-							 * PCI driver
-							 */
-#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
-							 * vid/did) of the
-							 * first PCI device
-							 */
-#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
-							 * vid/did) of the
-							 * next PCI device
-							 */
-#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
-							 * PCI device based on
-							 * bus/dev/function
-							 */
-#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
-							 * index
-							 */
-#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
-#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
-#define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
-							 * PCI device
-							 * (safecopy)
-							 */
-#define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
-							 * PCI slot (safecopy)
-							 */
-#define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
-							 * driver (safecopy)
-							 */
-#define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
-							 * driver 
-							 */
-#define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
-							 * Register properties
-							 */
-#define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
-							 * a segment of memory
-							 */
-
-#define BUSC_I2C_RESERVE	(BUSC_RQ_BASE + 64)	/* reserve i2c device */
-#define BUSC_I2C_EXEC		(BUSC_RQ_BASE + 65)	/* perform i2c action */
+#define BUSC_RQ_BASE 0x300 /* base for request types */
+#define BUSC_RS_BASE 0x380 /* base for response types */
+
+#define BUSC_PCI_INIT (BUSC_RQ_BASE + 0)				 /* First message to \
+																									* PCI driver       \
+																									*/
+#define BUSC_PCI_FIRST_DEV (BUSC_RQ_BASE + 1)		 /* Get index (and   \
+																									* vid/did) of the  \
+																									* first PCI device \
+																									*/
+#define BUSC_PCI_NEXT_DEV (BUSC_RQ_BASE + 2)		 /* Get index (and  \
+																									* vid/did) of the \
+																									* next PCI device \
+																									*/
+#define BUSC_PCI_FIND_DEV (BUSC_RQ_BASE + 3)		 /* Get index of a      \
+																									* PCI device based on \
+																									* bus/dev/function    \
+																									*/
+#define BUSC_PCI_IDS (BUSC_RQ_BASE + 4)					 /* Get vid/did from an \
+																									* index               \
+																									*/
+#define BUSC_PCI_RESERVE (BUSC_RQ_BASE + 7)			 /* Reserve a PCI dev */
+#define BUSC_PCI_ATTR_R8 (BUSC_RQ_BASE + 8)			 /* Read 8-bit      \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_ATTR_R16 (BUSC_RQ_BASE + 9)		 /* Read 16-bit     \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_ATTR_R32 (BUSC_RQ_BASE + 10)		 /* Read 32-bit     \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_ATTR_W8 (BUSC_RQ_BASE + 11)		 /* Write 8-bit     \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_ATTR_W16 (BUSC_RQ_BASE + 12)		 /* Write 16-bit    \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_ATTR_W32 (BUSC_RQ_BASE + 13)		 /* Write 32-bit    \
+																									* attribute value \
+																									*/
+#define BUSC_PCI_RESCAN (BUSC_RQ_BASE + 14)			 /* Rescan bus */
+#define BUSC_PCI_DEV_NAME_S (BUSC_RQ_BASE + 15)	/* Get the name of a \
+																									* PCI device        \
+																									* (safecopy)        \
+																									*/
+#define BUSC_PCI_SLOT_NAME_S (BUSC_RQ_BASE + 16) /* Get the name of a   \
+																									* PCI slot (safecopy) \
+																									*/
+#define BUSC_PCI_SET_ACL (BUSC_RQ_BASE + 17)		 /* Set the ACL for a \
+																									* driver (safecopy) \
+																									*/
+#define BUSC_PCI_DEL_ACL (BUSC_RQ_BASE + 18)		 /* Delete the ACL of a \
+																									* driver              \
+																									*/
+#define BUSC_PCI_GET_BAR (BUSC_RQ_BASE + 19)		 /* Get Base Address    \
+																									* Register properties \
+																									*/
+#define IOMMU_MAP (BUSC_RQ_BASE + 32)						 /* Ask IOMMU to map    \
+																									* a segment of memory \
+																									*/
+
+#define BUSC_I2C_RESERVE (BUSC_RQ_BASE + 64) /* reserve i2c device */
+#define BUSC_I2C_EXEC (BUSC_RQ_BASE + 65)		 /* perform i2c action */
 
 /*===========================================================================*
  *                  	   Messages for networking layer		     *
  *===========================================================================*/
 
 /* Base type for data link layer requests and responses. */
-#define DL_RQ_BASE	0x200		
-#define DL_RS_BASE	0x280		
+#define DL_RQ_BASE 0x200
+#define DL_RS_BASE 0x280
 
 #define IS_DL_RQ(type) (((type) & ~0x7f) == DL_RQ_BASE)
 #define IS_DL_RS(type) (((type) & ~0x7f) == DL_RS_BASE)
 
 /* Message types for data link layer requests. */
-#define DL_CONF		(DL_RQ_BASE + 0)
-#define DL_GETSTAT_S	(DL_RQ_BASE + 1)
-#define DL_WRITEV_S	(DL_RQ_BASE + 2)
-#define DL_READV_S	(DL_RQ_BASE + 3)
+#define DL_CONF (DL_RQ_BASE + 0)
+#define DL_GETSTAT_S (DL_RQ_BASE + 1)
+#define DL_WRITEV_S (DL_RQ_BASE + 2)
+#define DL_READV_S (DL_RQ_BASE + 3)
 
 /* Message type for data link layer replies. */
-#define DL_CONF_REPLY	(DL_RS_BASE + 0)
-#define DL_STAT_REPLY	(DL_RS_BASE + 1)
-#define DL_TASK_REPLY	(DL_RS_BASE + 2)
+#define DL_CONF_REPLY (DL_RS_BASE + 0)
+#define DL_STAT_REPLY (DL_RS_BASE + 1)
+#define DL_TASK_REPLY (DL_RS_BASE + 2)
 
 /* Bits in 'flags' field of DL replies. */
-#  define DL_NOFLAGS		0x00
-#  define DL_PACK_SEND		0x01
-#  define DL_PACK_RECV		0x02
+#define DL_NOFLAGS 0x00
+#define DL_PACK_SEND 0x01
+#define DL_PACK_RECV 0x02
 
 /* Bits in 'DL_MODE' field of DL requests. */
-#  define DL_NOMODE		0x0
-#  define DL_PROMISC_REQ	0x1
-#  define DL_MULTI_REQ		0x2
-#  define DL_BROAD_REQ		0x4
+#define DL_NOMODE 0x0
+#define DL_PROMISC_REQ 0x1
+#define DL_MULTI_REQ 0x2
+#define DL_BROAD_REQ 0x4
 
 /*===========================================================================*
  *                  SYSTASK request types and field names                    *
@@ -196,573 +196,575 @@
 /* System library calls are dispatched via a call vector, so be careful when 
  * modifying the system call numbers. The numbers here determine which call
  * is made from the call vector.
- */ 
-#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
+ */
+#define KERNEL_CALL 0x600 /* base for kernel calls to SYSTEM */
+
+#define SYS_FORK (KERNEL_CALL + 0)		 /* sys_fork() */
+#define SYS_EXEC (KERNEL_CALL + 1)		 /* sys_exec() */
+#define SYS_CLEAR (KERNEL_CALL + 2)		 /* sys_clear() */
+#define SYS_SCHEDULE (KERNEL_CALL + 3) /* sys_schedule() */
+#define SYS_PRIVCTL (KERNEL_CALL + 4)	/* sys_privctl() */
+#define SYS_TRACE (KERNEL_CALL + 5)		 /* sys_trace() */
+#define SYS_KILL (KERNEL_CALL + 6)		 /* sys_kill() */
 
-#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
-#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
-#  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
-#  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
-#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
-#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
-#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
+#define SYS_GETKSIG (KERNEL_CALL + 7)		 /* sys_getsig() */
+#define SYS_ENDKSIG (KERNEL_CALL + 8)		 /* sys_endsig() */
+#define SYS_SIGSEND (KERNEL_CALL + 9)		 /* sys_sigsend() */
+#define SYS_SIGRETURN (KERNEL_CALL + 10) /* sys_sigreturn() */
 
-#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
-#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
-#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
-#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
+#define SYS_MEMSET (KERNEL_CALL + 13) /* sys_memset() */
 
-#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
+#define SYS_UMAP (KERNEL_CALL + 14)				 /* sys_umap() */
+#define SYS_VIRCOPY (KERNEL_CALL + 15)		 /* sys_vircopy() */
+#define SYS_PHYSCOPY (KERNEL_CALL + 16)		 /* sys_physcopy() */
+#define SYS_UMAP_REMOTE (KERNEL_CALL + 17) /* sys_umap_remote() */
+#define SYS_VUMAP (KERNEL_CALL + 18)			 /* sys_vumap() */
 
-#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
-#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
-#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
-#  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
-#  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
+#define SYS_IRQCTL (KERNEL_CALL + 19) /* sys_irqctl() */
+#define SYS_INT86 (KERNEL_CALL + 20)	/* sys_int86() */
+#define SYS_DEVIO (KERNEL_CALL + 21)	/* sys_devio() */
+#define SYS_SDEVIO (KERNEL_CALL + 22) /* sys_sdevio() */
+#define SYS_VDEVIO (KERNEL_CALL + 23) /* sys_vdevio() */
 
-#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
-#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
-#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
-#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
-#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
+#define SYS_SETALARM (KERNEL_CALL + 24)			/* sys_setalarm() */
+#define SYS_TIMES (KERNEL_CALL + 25)				/* sys_times() */
+#define SYS_GETINFO (KERNEL_CALL + 26)			/* sys_getinfo() */
+#define SYS_ABORT (KERNEL_CALL + 27)				/* sys_abort() */
+#define SYS_IOPENABLE (KERNEL_CALL + 28)		/* sys_enable_iop() */
+#define SYS_SAFECOPYFROM (KERNEL_CALL + 31) /* sys_safecopyfrom() */
+#define SYS_SAFECOPYTO (KERNEL_CALL + 32)		/* sys_safecopyto() */
+#define SYS_VSAFECOPY (KERNEL_CALL + 33)		/* sys_vsafecopy() */
+#define SYS_SETGRANT (KERNEL_CALL + 34)			/* sys_setgrant() */
+#define SYS_READBIOS (KERNEL_CALL + 35)			/* sys_readbios() */
 
-#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
-#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
-#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
-#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
-#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
-#  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
-#  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
-#  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
-#  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
-#  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
+#define SYS_SPROF (KERNEL_CALL + 36)	 /* sys_sprof() */
+#define SYS_CPROF (KERNEL_CALL + 37)	 /* sys_cprof() */
+#define SYS_PROFBUF (KERNEL_CALL + 38) /* sys_profbuf() */
 
-#  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
-#  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
-#  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
+#define SYS_STIME (KERNEL_CALL + 39)	 /* sys_stime() */
+#define SYS_SETTIME (KERNEL_CALL + 40) /* sys_settime() */
 
-#  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
-#  define SYS_SETTIME    (KERNEL_CALL + 40)	/* sys_settime() */
+#define SYS_VMCTL (KERNEL_CALL + 43) /* sys_vmctl() */
 
-#  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
+#define SYS_DIAGCTL (KERNEL_CALL + 44) /* sys_diagctl() */
 
-#  define SYS_DIAGCTL    (KERNEL_CALL + 44)	/* sys_diagctl() */
+#define SYS_VTIMER (KERNEL_CALL + 45)			 /* sys_vtimer() */
+#define SYS_RUNCTL (KERNEL_CALL + 46)			 /* sys_runctl() */
+#define SYS_GETMCONTEXT (KERNEL_CALL + 50) /* sys_getmcontext() */
+#define SYS_SETMCONTEXT (KERNEL_CALL + 51) /* sys_setmcontext() */
 
-#  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
-#  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
-#  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
-#  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
+#define SYS_UPDATE (KERNEL_CALL + 52) /* sys_update() */
+#define SYS_EXIT (KERNEL_CALL + 53)		/* sys_exit() */
 
-#  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
-#  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
+#define SYS_SCHEDCTL (KERNEL_CALL + 54) /* sys_schedctl() */
+#define SYS_STATECTL (KERNEL_CALL + 55) /* sys_statectl() */
 
-#  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
-#  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
+#define SYS_SAFEMEMSET (KERNEL_CALL + 56) /* sys_safememset() */
 
-#  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
+#define SYS_PADCONF (KERNEL_CALL + 57) /* sys_padconf() */
 
-#  define SYS_PADCONF (KERNEL_CALL + 57)	/* sys_padconf() */
+#define SYS_CHRT (KERNEL_CALL + 58) /* sys_chrt() */
 
 /* Total */
-#define NR_SYS_CALLS	58	/* number of kernel calls */
+#define NR_SYS_CALLS 59 /* number of kernel calls */
 
 #define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
 
 /* Basic kernel calls allowed to every system process. */
-#define SYS_BASIC_CALLS \
-    SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
-    SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
-    SYS_PROFBUF, SYS_DIAGCTL, SYS_STATECTL, SYS_SAFEMEMSET
+#define SYS_BASIC_CALLS                                                   \
+	SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
+			SYS_TIMES, SYS_SETALARM, SYS_SETGRANT,                              \
+			SYS_PROFBUF, SYS_DIAGCTL, SYS_STATECTL, SYS_SAFEMEMSET
 
 /* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
-#   define _DIO_INPUT		0x001
-#   define _DIO_OUTPUT		0x002
-#   define _DIO_DIRMASK		0x00f
-#   define _DIO_BYTE		0x010
-#   define _DIO_WORD		0x020
-#   define _DIO_LONG		0x030
-#   define _DIO_TYPEMASK	0x0f0
-#   define _DIO_SAFE		0x100
-#   define _DIO_SAFEMASK	0xf00
-#   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
-#   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
-#   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
-#   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
-#   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
-#   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
-#   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
-#   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
-#   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
+#define _DIO_INPUT 0x001
+#define _DIO_OUTPUT 0x002
+#define _DIO_DIRMASK 0x00f
+#define _DIO_BYTE 0x010
+#define _DIO_WORD 0x020
+#define _DIO_LONG 0x030
+#define _DIO_TYPEMASK 0x0f0
+#define _DIO_SAFE 0x100
+#define _DIO_SAFEMASK 0xf00
+#define DIO_INPUT_BYTE (_DIO_INPUT | _DIO_BYTE)
+#define DIO_INPUT_WORD (_DIO_INPUT | _DIO_WORD)
+#define DIO_INPUT_LONG (_DIO_INPUT | _DIO_LONG)
+#define DIO_OUTPUT_BYTE (_DIO_OUTPUT | _DIO_BYTE)
+#define DIO_OUTPUT_WORD (_DIO_OUTPUT | _DIO_WORD)
+#define DIO_OUTPUT_LONG (_DIO_OUTPUT | _DIO_LONG)
+#define DIO_SAFE_INPUT_BYTE (_DIO_INPUT | _DIO_BYTE | _DIO_SAFE)
+#define DIO_SAFE_INPUT_WORD (_DIO_INPUT | _DIO_WORD | _DIO_SAFE)
+#define DIO_SAFE_INPUT_LONG (_DIO_INPUT | _DIO_LONG | _DIO_SAFE)
+#define DIO_SAFE_OUTPUT_BYTE (_DIO_OUTPUT | _DIO_BYTE | _DIO_SAFE)
+#define DIO_SAFE_OUTPUT_WORD (_DIO_OUTPUT | _DIO_WORD | _DIO_SAFE)
+#define DIO_SAFE_OUTPUT_LONG (_DIO_OUTPUT | _DIO_LONG | _DIO_SAFE)
 
 /* Field names for SYS_IRQCTL. */
-#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
-#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
-#  define IRQ_ENABLE        3	/* enable interrupts */
-#  define IRQ_DISABLE       4	/* disable interrupts */
-#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
-#  define IRQ_BYTE      0x100	/* byte values */      
-#  define IRQ_WORD      0x200	/* word values */
-#  define IRQ_LONG      0x400	/* long values */
+#define IRQ_SETPOLICY 1		 /* manage a slot of the IRQ table */
+#define IRQ_RMPOLICY 2		 /* remove a slot of the IRQ table */
+#define IRQ_ENABLE 3			 /* enable interrupts */
+#define IRQ_DISABLE 4			 /* disable interrupts */
+#define IRQ_REENABLE 0x001 /* reenable IRQ line after interrupt */
+#define IRQ_BYTE 0x100		 /* byte values */
+#define IRQ_WORD 0x200		 /* word values */
+#define IRQ_LONG 0x400		 /* long values */
 
-#define CP_FLAG_TRY	0x01	/* do not transparently map */
+#define CP_FLAG_TRY 0x01 /* do not transparently map */
 
 /* Field names for SYS_GETINFO. */
-#   define GET_KINFO	   0	/* get kernel information structure */
-#   define GET_IMAGE	   1	/* get system image table */
-#   define GET_PROCTAB	   2	/* get kernel process table */
-#   define GET_RANDOMNESS  3	/* get randomness buffer */
-#   define GET_MONPARAMS   4	/* get monitor parameters */
-#   define GET_KENV	   5	/* get kernel environment string */
-#   define GET_IRQHOOKS	   6	/* get the IRQ table */
-#   define GET_PRIVTAB	   8	/* get kernel privileges table */
-#   define GET_KADDRESSES  9	/* get various kernel addresses */
-#   define GET_SCHEDINFO  10	/* get scheduling queues */
-#   define GET_PROC 	  11	/* get process slot if given process */
-#   define GET_MACHINE 	  12	/* get machine information */
-#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
-#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
-#   define GET_LOADINFO   15	/* get load average information */
-#   define GET_IRQACTIDS  16	/* get the IRQ masks */
-#   define GET_PRIV	  17	/* get privilege structure */
-#   define GET_HZ	  18	/* get HZ value */
-#   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
-#   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
-#   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
-#   define GET_CPUINFO    23    /* get information about cpus */
-#   define GET_REGS	  24	/* get general process registers */
-#   define GET_RUSAGE	  25	/* get resource usage */
+#define GET_KINFO 0						/* get kernel information structure */
+#define GET_IMAGE 1						/* get system image table */
+#define GET_PROCTAB 2					/* get kernel process table */
+#define GET_RANDOMNESS 3			/* get randomness buffer */
+#define GET_MONPARAMS 4				/* get monitor parameters */
+#define GET_KENV 5						/* get kernel environment string */
+#define GET_IRQHOOKS 6				/* get the IRQ table */
+#define GET_PRIVTAB 8					/* get kernel privileges table */
+#define GET_KADDRESSES 9			/* get various kernel addresses */
+#define GET_SCHEDINFO 10			/* get scheduling queues */
+#define GET_PROC 11						/* get process slot if given process */
+#define GET_MACHINE 12				/* get machine information */
+#define GET_LOCKTIMING 13			/* get lock()/unlock() latency timing */
+#define GET_BIOSBUFFER 14			/* get a buffer for BIOS calls */
+#define GET_LOADINFO 15				/* get load average information */
+#define GET_IRQACTIDS 16			/* get the IRQ masks */
+#define GET_PRIV 17						/* get privilege structure */
+#define GET_HZ 18							/* get HZ value */
+#define GET_WHOAMI 19					/* get own name, endpoint, and privileges */
+#define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
+#define GET_IDLETSC 21				/* get cumulative idle time stamp counter */
+#define GET_CPUINFO 23				/* get information about cpus */
+#define GET_REGS 24						/* get general process registers */
+#define GET_RUSAGE 25					/* get resource usage */
 
 /* Subfunctions for SYS_PRIVCTL */
-#define SYS_PRIV_ALLOW		1	/* Allow process to run */
-#define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
-#define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
-#define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
-#define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
-#define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
-					 */
-#define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
-#define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
-#define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
-#define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
+#define SYS_PRIV_ALLOW 1			/* Allow process to run */
+#define SYS_PRIV_DISALLOW 2		/* Disallow process to run */
+#define SYS_PRIV_SET_SYS 3		/* Set a system privilege structure */
+#define SYS_PRIV_SET_USER 4		/* Set a user privilege structure */
+#define SYS_PRIV_ADD_IO 5			/* Add I/O range (struct io_range) */
+#define SYS_PRIV_ADD_MEM 6		/* Add memory range (struct mem_range) \
+															 */
+#define SYS_PRIV_ADD_IRQ 7		/* Add IRQ */
+#define SYS_PRIV_QUERY_MEM 8	/* Verify memory privilege. */
+#define SYS_PRIV_UPDATE_SYS 9 /* Update a sys privilege structure. */
+#define SYS_PRIV_YIELD 10			/* Allow process to run and suspend */
 
 /* Constants for exec. FIXME: these do not belong here. */
-#define PMEF_AUXVECTORS	20
+#define PMEF_AUXVECTORS 20
 #define PMEF_EXECNAMELEN1 PATH_MAX
 
 /* Flags for PR_FORK_FLAGS. */
-#define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
+#define PFF_VMINHIBIT 0x01 /* Don't schedule until release by VM. */
 
 /* SYS_SAFEMEMSET */
-#define SMS_DST		m2_i1	/* dst endpoint */
-#define SMS_GID		m2_i3	/* grant id */
-#define SMS_OFFSET	m2_l1	/* offset within grant */
-#define SMS_BYTES	m2_l2	/* bytes from offset */
-#define SMS_PATTERN	m2_i2	/* memset() pattern */
+#define SMS_DST m2_i1			/* dst endpoint */
+#define SMS_GID m2_i3			/* grant id */
+#define SMS_OFFSET m2_l1	/* offset within grant */
+#define SMS_BYTES m2_l2		/* bytes from offset */
+#define SMS_PATTERN m2_i2 /* memset() pattern */
 
 /* Field names for SYS_VMCTL. */
-#define SVMCTL_WHO	m1_i1
-#define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
-#define SVMCTL_VALUE	m1_i3
-#define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
-#define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
-#define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
-#define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
-#define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
-#define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
-#define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
-#define SVMCTL_MAP_VIR_ADDR	m1_p1
-#define SVMCTL_PTROOT		m1_i3
-#define SVMCTL_PTROOT_V		m1_p1
+#define SVMCTL_WHO m1_i1
+#define SVMCTL_PARAM m1_i2 /* All SYS_VMCTL requests. */
+#define SVMCTL_VALUE m1_i3
+#define SVMCTL_MRG_TARGET m2_i1		 /* MEMREQ_GET reply: target process */
+#define SVMCTL_MRG_ADDR m2_i2			 /* MEMREQ_GET reply: address */
+#define SVMCTL_MRG_LENGTH m2_i3		 /* MEMREQ_GET reply: length */
+#define SVMCTL_MRG_FLAG m2_s1			 /* MEMREQ_GET reply: flag */
+#define SVMCTL_MRG_EP2 m2_l1			 /* MEMREQ_GET reply: source process */
+#define SVMCTL_MRG_ADDR2 m2_l2		 /* MEMREQ_GET reply: source address */
+#define SVMCTL_MRG_REQUESTOR m2_p1 /* MEMREQ_GET reply: requestor */
+#define SVMCTL_MAP_VIR_ADDR m1_p1
+#define SVMCTL_PTROOT m1_i3
+#define SVMCTL_PTROOT_V m1_p1
 
 /* Reply message for VMCTL_KERN_PHYSMAP */
-#define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
-#define SVMCTL_MAP_PHYS_ADDR	m2_l1
-#define SVMCTL_MAP_PHYS_LEN	m2_l2
+#define SVMCTL_MAP_FLAGS m2_i1 /* VMMF_* */
+#define SVMCTL_MAP_PHYS_ADDR m2_l1
+#define SVMCTL_MAP_PHYS_LEN m2_l2
 
-#define VMMF_UNCACHED		(1L << 0)
-#define VMMF_USER		(1L << 1)
-#define VMMF_WRITE		(1L << 2)
-#define VMMF_GLO		(1L << 3)
+#define VMMF_UNCACHED (1L << 0)
+#define VMMF_USER (1L << 1)
+#define VMMF_WRITE (1L << 2)
+#define VMMF_GLO (1L << 3)
 
 /* Values for SVMCTL_PARAM. */
-#define VMCTL_CLEAR_PAGEFAULT	12
-#define VMCTL_GET_PDBR		13
-#define VMCTL_MEMREQ_GET 	14
-#define VMCTL_MEMREQ_REPLY	15
-#define VMCTL_NOPAGEZERO	18
-#define VMCTL_I386_KERNELLIMIT	19
-#define VMCTL_I386_INVLPG	25
-#define VMCTL_FLUSHTLB		26
-#define VMCTL_KERN_PHYSMAP	27
-#define VMCTL_KERN_MAP_REPLY	28
-#define VMCTL_SETADDRSPACE	29
-#define VMCTL_VMINHIBIT_SET	30
-#define VMCTL_VMINHIBIT_CLEAR	31
-#define VMCTL_CLEARMAPCACHE	32
-#define VMCTL_BOOTINHIBIT_CLEAR	33
+#define VMCTL_CLEAR_PAGEFAULT 12
+#define VMCTL_GET_PDBR 13
+#define VMCTL_MEMREQ_GET 14
+#define VMCTL_MEMREQ_REPLY 15
+#define VMCTL_NOPAGEZERO 18
+#define VMCTL_I386_KERNELLIMIT 19
+#define VMCTL_I386_INVLPG 25
+#define VMCTL_FLUSHTLB 26
+#define VMCTL_KERN_PHYSMAP 27
+#define VMCTL_KERN_MAP_REPLY 28
+#define VMCTL_SETADDRSPACE 29
+#define VMCTL_VMINHIBIT_SET 30
+#define VMCTL_VMINHIBIT_CLEAR 31
+#define VMCTL_CLEARMAPCACHE 32
+#define VMCTL_BOOTINHIBIT_CLEAR 33
 
 /* Codes and field names for SYS_DIAGCTL. */
-#define DIAGCTL_CODE_DIAG	1	/* Print diagnostics. */
-#define DIAGCTL_CODE_STACKTRACE	2	/* Print process stack. */
-#define DIAGCTL_CODE_REGISTER	3	/* Register for diagnostic signals */
-#define DIAGCTL_CODE_UNREGISTER	4	/* Unregister for diagnostic signals */
-#define DIAG_BUFSIZE	(80*25)
+#define DIAGCTL_CODE_DIAG 1				/* Print diagnostics. */
+#define DIAGCTL_CODE_STACKTRACE 2 /* Print process stack. */
+#define DIAGCTL_CODE_REGISTER 3		/* Register for diagnostic signals */
+#define DIAGCTL_CODE_UNREGISTER 4 /* Unregister for diagnostic signals */
+#define DIAG_BUFSIZE (80 * 25)
 
 /* Field names for SYS_VTIMER. */
-#define VT_WHICH	m2_i1	/* which timer to set/retrieve */
-#  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
-#  define VT_PROF           2	/* the ITIMER_PROF timer */
-#define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
-#define VT_VALUE	m2_l1	/* new/previous value of the timer */
-#define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
+#define VT_WHICH m2_i1 /* which timer to set/retrieve */
+#define VT_VIRTUAL 1	 /* the ITIMER_VIRTUAL timer */
+#define VT_PROF 2			 /* the ITIMER_PROF timer */
+#define VT_SET m2_i2	 /* 1 for setting a timer, 0 retrieval only */
+#define VT_VALUE m2_l1 /* new/previous value of the timer */
+#define VT_ENDPT m2_l2 /* process to set/retrieve the timer for */
 
 /* Field names for SYS_RUNCTL. */
-#define RC_ENDPT	m1_i1	/* which process to stop or resume */
-#define RC_ACTION	m1_i2	/* set or clear stop flag */
-#  define RC_STOP           0	/* stop the process */
-#  define RC_RESUME         1	/* clear the stop flag */
-#define RC_FLAGS	m1_i3	/* request flags */
-#  define RC_DELAY          1	/* delay stop if process is sending */
+#define RC_ENDPT m1_i1	/* which process to stop or resume */
+#define RC_ACTION m1_i2 /* set or clear stop flag */
+#define RC_STOP 0				/* stop the process */
+#define RC_RESUME 1			/* clear the stop flag */
+#define RC_FLAGS m1_i3	/* request flags */
+#define RC_DELAY 1			/* delay stop if process is sending */
 
 /* Field names for SYS_UPDATE. */
-#define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
-#define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
+#define SYS_UPD_SRC_ENDPT m1_i1 /* source endpoint */
+#define SYS_UPD_DST_ENDPT m1_i2 /* destination endpoint */
 
 /* Subfunctions for SYS_STATECTL */
-#define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
+#define SYS_STATE_CLEAR_IPC_REFS 1 /* clear IPC references */
 
 /* Subfunctions for SYS_SCHEDCTL */
-#  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
-					 * RTS_NO_QUANTUM; otherwise caller is 
-					 * marked scheduler 
-					 */
+#define SCHEDCTL_FLAG_KERNEL 1 /* mark kernel scheduler and remove    \
+																* RTS_NO_QUANTUM; otherwise caller is \
+																* marked scheduler                    \
+																*/
 
 /* Field names for SYS_PADCONF */
-#define PADCONF_PADCONF		m2_i1	/* pad to configure */
-#define PADCONF_MASK		m2_i2	/* mask to apply */
-#define PADCONF_VALUE		m2_i3	/* value to write */
+#define PADCONF_PADCONF m2_i1 /* pad to configure */
+#define PADCONF_MASK m2_i2		/* mask to apply */
+#define PADCONF_VALUE m2_i3		/* value to write */
 
 /*===========================================================================*
  *                Messages for the Reincarnation Server 		     *
  *===========================================================================*/
 
-#define RS_RQ_BASE		0x700
+#define RS_RQ_BASE 0x700
 
-#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
-#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
-#define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
-#define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
-#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
-#define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
-#define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
-#define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
+#define RS_UP (RS_RQ_BASE + 0)			 /* start system service */
+#define RS_DOWN (RS_RQ_BASE + 1)		 /* stop system service */
+#define RS_REFRESH (RS_RQ_BASE + 2)	/* refresh system service */
+#define RS_RESTART (RS_RQ_BASE + 3)	/* restart system service */
+#define RS_SHUTDOWN (RS_RQ_BASE + 4) /* alert about shutdown */
+#define RS_UPDATE (RS_RQ_BASE + 5)	 /* update system service */
+#define RS_CLONE (RS_RQ_BASE + 6)		 /* clone system service */
+#define RS_EDIT (RS_RQ_BASE + 7)		 /* edit system service */
 
-#define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
+#define RS_LOOKUP (RS_RQ_BASE + 8) /* lookup server name */
 
-#define RS_GETSYSINFO	(RS_RQ_BASE + 9)	/* get system information */
+#define RS_GETSYSINFO (RS_RQ_BASE + 9) /* get system information */
 
-#define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
-#define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
+#define RS_INIT (RS_RQ_BASE + 20)				/* service init message */
+#define RS_LU_PREPARE (RS_RQ_BASE + 21) /* prepare to update message */
 
 /*===========================================================================*
  *                Messages for the Data Store Server			     *
  *===========================================================================*/
 
-#define DS_RQ_BASE		0x800
+#define DS_RQ_BASE 0x800
 
-#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
-#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
-#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
-#define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
-#define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
-#define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
-#define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
-#define DS_GETSYSINFO	(DS_RQ_BASE + 7)	/* get system information */
+#define DS_PUBLISH (DS_RQ_BASE + 0)				 /* publish data */
+#define DS_RETRIEVE (DS_RQ_BASE + 1)			 /* retrieve data by name */
+#define DS_SUBSCRIBE (DS_RQ_BASE + 2)			 /* subscribe to data updates */
+#define DS_CHECK (DS_RQ_BASE + 3)					 /* retrieve updated data */
+#define DS_DELETE (DS_RQ_BASE + 4)				 /* delete data */
+#define DS_SNAPSHOT (DS_RQ_BASE + 5)			 /* take a snapshot */
+#define DS_RETRIEVE_LABEL (DS_RQ_BASE + 6) /* retrieve label's name */
+#define DS_GETSYSINFO (DS_RQ_BASE + 7)		 /* get system information */
 
 /*===========================================================================*
  *                Messages used between PM and VFS			     *
  *===========================================================================*/
 
-#define VFS_PM_RQ_BASE	0x900
-#define VFS_PM_RS_BASE	0x980
+#define VFS_PM_RQ_BASE 0x900
+#define VFS_PM_RS_BASE 0x980
 
 #define IS_VFS_PM_RQ(type) (((type) & ~0x7f) == VFS_PM_RQ_BASE)
 #define IS_VFS_PM_RS(type) (((type) & ~0x7f) == VFS_PM_RS_BASE)
 
 /* Requests from PM to VFS. */
-#define VFS_PM_INIT	(VFS_PM_RQ_BASE + 0)	/* Process table exchange */
-#define VFS_PM_SETUID	(VFS_PM_RQ_BASE + 1)	/* Set new user ID */
-#define VFS_PM_SETGID	(VFS_PM_RQ_BASE + 2)	/* Set group ID */
-#define VFS_PM_SETSID	(VFS_PM_RQ_BASE + 3)	/* Set session leader */
-#define VFS_PM_EXIT	(VFS_PM_RQ_BASE + 4)	/* Process exits */
-#define VFS_PM_DUMPCORE	(VFS_PM_RQ_BASE + 5)	/* Process is to dump core */
-#define VFS_PM_EXEC	(VFS_PM_RQ_BASE + 6)	/* Forwarded exec call */
-#define VFS_PM_FORK	(VFS_PM_RQ_BASE + 7)	/* Newly forked process */
-#define VFS_PM_SRV_FORK	(VFS_PM_RQ_BASE + 8)	/* fork for system services */
-#define VFS_PM_UNPAUSE	(VFS_PM_RQ_BASE + 9)	/* Interrupt process call */
-#define VFS_PM_REBOOT	(VFS_PM_RQ_BASE + 10)	/* System reboot */
-#define VFS_PM_SETGROUPS	(VFS_PM_RQ_BASE + 11)	/* Set groups */
+#define VFS_PM_INIT (VFS_PM_RQ_BASE + 0)			 /* Process table exchange */
+#define VFS_PM_SETUID (VFS_PM_RQ_BASE + 1)		 /* Set new user ID */
+#define VFS_PM_SETGID (VFS_PM_RQ_BASE + 2)		 /* Set group ID */
+#define VFS_PM_SETSID (VFS_PM_RQ_BASE + 3)		 /* Set session leader */
+#define VFS_PM_EXIT (VFS_PM_RQ_BASE + 4)			 /* Process exits */
+#define VFS_PM_DUMPCORE (VFS_PM_RQ_BASE + 5)	 /* Process is to dump core */
+#define VFS_PM_EXEC (VFS_PM_RQ_BASE + 6)			 /* Forwarded exec call */
+#define VFS_PM_FORK (VFS_PM_RQ_BASE + 7)			 /* Newly forked process */
+#define VFS_PM_SRV_FORK (VFS_PM_RQ_BASE + 8)	 /* fork for system services */
+#define VFS_PM_UNPAUSE (VFS_PM_RQ_BASE + 9)		 /* Interrupt process call */
+#define VFS_PM_REBOOT (VFS_PM_RQ_BASE + 10)		 /* System reboot */
+#define VFS_PM_SETGROUPS (VFS_PM_RQ_BASE + 11) /* Set groups */
 
 /* Replies from VFS to PM */
-#define VFS_PM_SETUID_REPLY	(VFS_PM_RS_BASE + 1)
-#define VFS_PM_SETGID_REPLY	(VFS_PM_RS_BASE + 2)
-#define VFS_PM_SETSID_REPLY	(VFS_PM_RS_BASE + 3)
-#define VFS_PM_EXIT_REPLY	(VFS_PM_RS_BASE + 4)
-#define VFS_PM_CORE_REPLY	(VFS_PM_RS_BASE + 5)
-#define VFS_PM_EXEC_REPLY	(VFS_PM_RS_BASE + 6)
-#define VFS_PM_FORK_REPLY	(VFS_PM_RS_BASE + 7)
-#define VFS_PM_SRV_FORK_REPLY	(VFS_PM_RS_BASE + 8)
-#define VFS_PM_UNPAUSE_REPLY	(VFS_PM_RS_BASE + 9)
-#define VFS_PM_REBOOT_REPLY	(VFS_PM_RS_BASE + 10)
-#define VFS_PM_SETGROUPS_REPLY	(VFS_PM_RS_BASE + 11)
+#define VFS_PM_SETUID_REPLY (VFS_PM_RS_BASE + 1)
+#define VFS_PM_SETGID_REPLY (VFS_PM_RS_BASE + 2)
+#define VFS_PM_SETSID_REPLY (VFS_PM_RS_BASE + 3)
+#define VFS_PM_EXIT_REPLY (VFS_PM_RS_BASE + 4)
+#define VFS_PM_CORE_REPLY (VFS_PM_RS_BASE + 5)
+#define VFS_PM_EXEC_REPLY (VFS_PM_RS_BASE + 6)
+#define VFS_PM_FORK_REPLY (VFS_PM_RS_BASE + 7)
+#define VFS_PM_SRV_FORK_REPLY (VFS_PM_RS_BASE + 8)
+#define VFS_PM_UNPAUSE_REPLY (VFS_PM_RS_BASE + 9)
+#define VFS_PM_REBOOT_REPLY (VFS_PM_RS_BASE + 10)
+#define VFS_PM_SETGROUPS_REPLY (VFS_PM_RS_BASE + 11)
 
 /* Standard parameters for all requests and replies, except PM_REBOOT */
-#  define VFS_PM_ENDPT		m7_i1	/* process endpoint */
+#define VFS_PM_ENDPT m7_i1 /* process endpoint */
 
 /* Additional parameters for PM_INIT */
-#  define VFS_PM_SLOT		m7_i2	/* process slot number */
-#  define VFS_PM_PID		m7_i3	/* process pid */
+#define VFS_PM_SLOT m7_i2 /* process slot number */
+#define VFS_PM_PID m7_i3	/* process pid */
 
 /* Additional parameters for PM_SETUID and PM_SETGID */
-#  define VFS_PM_EID		m7_i2	/* effective user/group id */
-#  define VFS_PM_RID		m7_i3	/* real user/group id */
+#define VFS_PM_EID m7_i2 /* effective user/group id */
+#define VFS_PM_RID m7_i3 /* real user/group id */
 
 /* Additional parameter for PM_SETGROUPS */
-#  define VFS_PM_GROUP_NO	m7_i2	/* number of groups */
-#  define VFS_PM_GROUP_ADDR	m7_p1	/* struct holding group data */
+#define VFS_PM_GROUP_NO m7_i2		/* number of groups */
+#define VFS_PM_GROUP_ADDR m7_p1 /* struct holding group data */
 
 /* Additional parameters for PM_EXEC */
-#  define VFS_PM_PATH		m7_p1	/* executable */
-#  define VFS_PM_PATH_LEN	m7_i2	/* length of path including
-					 * terminating null character
-					 */
-#  define VFS_PM_FRAME		m7_p2	/* arguments and environment */
-#  define VFS_PM_FRAME_LEN	m7_i3	/* size of frame */
-#  define VFS_PM_PS_STR		m7_i5	/* ps_strings pointer */
+#define VFS_PM_PATH m7_p1			 /* executable */
+#define VFS_PM_PATH_LEN m7_i2	/* length of path including   \
+																* terminating null character \
+																*/
+#define VFS_PM_FRAME m7_p2		 /* arguments and environment */
+#define VFS_PM_FRAME_LEN m7_i3 /* size of frame */
+#define VFS_PM_PS_STR m7_i5		 /* ps_strings pointer */
 
 /* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
-#  define VFS_PM_STATUS		m7_i2	/* OK or failure */
-#  define VFS_PM_PC		m7_p1	/* program counter */
-#  define VFS_PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
-#  define VFS_PM_NEWPS_STR	m7_i5	/* possibly-changed ps_strings ptr */
+#define VFS_PM_STATUS m7_i2		 /* OK or failure */
+#define VFS_PM_PC m7_p1				 /* program counter */
+#define VFS_PM_NEWSP m7_p2		 /* possibly-changed stack ptr */
+#define VFS_PM_NEWPS_STR m7_i5 /* possibly-changed ps_strings ptr */
 
 /* Additional parameters for PM_FORK and PM_SRV_FORK */
-#  define VFS_PM_PENDPT		m7_i2	/* parent process endpoint */
-#  define VFS_PM_CPID		m7_i3	/* child pid */
-#  define VFS_PM_REUID		m7_i4	/* real and effective uid */
-#  define VFS_PM_REGID		m7_i5	/* real and effective gid */
+#define VFS_PM_PENDPT m7_i2 /* parent process endpoint */
+#define VFS_PM_CPID m7_i3		/* child pid */
+#define VFS_PM_REUID m7_i4	/* real and effective uid */
+#define VFS_PM_REGID m7_i5	/* real and effective gid */
 
 /* Additional parameters for PM_DUMPCORE */
-#  define VFS_PM_TERM_SIG	m7_i2	/* process's termination signal */
+#define VFS_PM_TERM_SIG m7_i2 /* process's termination signal */
 
 /*===========================================================================*
  *                Messages used from VFS to file servers		     *
  *===========================================================================*/
 
-#define FS_BASE		0xA00		/* Requests sent by VFS to filesystem
-					 * implementations. See <minix/vfsif.h>
-					 */
+#define FS_BASE 0xA00 /* Requests sent by VFS to filesystem   \
+											 * implementations. See <minix/vfsif.h> \
+											 */
 
 /*===========================================================================*
  *                Common requests and miscellaneous field names		     *
  *===========================================================================*/
 
-#define COMMON_RQ_BASE		0xE00
+#define COMMON_RQ_BASE 0xE00
 
 /* Field names for system signals (sent by a signal manager). */
-#define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
+#define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE + 0)
 
 /* Common request to all processes: gcov data. */
-#define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
+#define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE + 1)
 
 /* Common fault injection ctl request to all processes. */
-#define COMMON_REQ_FI_CTL (COMMON_RQ_BASE+2)
+#define COMMON_REQ_FI_CTL (COMMON_RQ_BASE + 2)
 
 /*===========================================================================*
  *                Messages for VM server				     *
  *===========================================================================*/
-#define VM_RQ_BASE		0xC00
+#define VM_RQ_BASE 0xC00
 
 /* Calls from PM */
-#define VM_EXIT			(VM_RQ_BASE+0)
-#	define VME_ENDPOINT		m1_i1
-#define VM_FORK			(VM_RQ_BASE+1)
-#	define VMF_ENDPOINT		m1_i1
-#	define VMF_SLOTNO		m1_i2
-#	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
-#define VM_BRK			(VM_RQ_BASE+2)
-#define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
-#	define VMEN_ENDPOINT		m1_i1
-#	define VMEN_ARGSPTR		m1_p1
-#	define VMEN_ARGSSIZE		m1_i2
-#	define VMEN_FLAGS		m1_i3	/* result */
-#	define VMEN_STACK_TOP		m1_p2	/* result */
-#define VM_WILLEXIT		(VM_RQ_BASE+5)
-#	define VMWE_ENDPOINT		m1_i1
+#define VM_EXIT (VM_RQ_BASE + 0)
+#define VME_ENDPOINT m1_i1
+#define VM_FORK (VM_RQ_BASE + 1)
+#define VMF_ENDPOINT m1_i1
+#define VMF_SLOTNO m1_i2
+#define VMF_CHILD_ENDPOINT m1_i3 /* result */
+#define VM_BRK (VM_RQ_BASE + 2)
+#define VM_EXEC_NEWMEM (VM_RQ_BASE + 3)
+#define VMEN_ENDPOINT m1_i1
+#define VMEN_ARGSPTR m1_p1
+#define VMEN_ARGSSIZE m1_i2
+#define VMEN_FLAGS m1_i3		 /* result */
+#define VMEN_STACK_TOP m1_p2 /* result */
+#define VM_WILLEXIT (VM_RQ_BASE + 5)
+#define VMWE_ENDPOINT m1_i1
 
 /* General calls. */
-#define VM_MMAP			(VM_RQ_BASE+10)
+#define VM_MMAP (VM_RQ_BASE + 10)
 
-#define VM_MUNMAP		(VM_RQ_BASE+17)
-#	define VMUM_ADDR		m_mmap.addr
-#	define VMUM_LEN			m_mmap.len
+#define VM_MUNMAP (VM_RQ_BASE + 17)
+#define VMUM_ADDR m_mmap.addr
+#define VMUM_LEN m_mmap.len
 
 /* to VM: inform VM about a region of memory that is used for
  * bus-master DMA
  */
-#define VM_ADDDMA	(VM_RQ_BASE+12)
-#	define VMAD_EP			m2_i1
-#	define VMAD_START		m2_l1
-#	define VMAD_SIZE		m2_l2
+#define VM_ADDDMA (VM_RQ_BASE + 12)
+#define VMAD_EP m2_i1
+#define VMAD_START m2_l1
+#define VMAD_SIZE m2_l2
 
 /* to VM: inform VM that a region of memory that is no longer
  * used for bus-master DMA
  */
-#define VM_DELDMA       (VM_RQ_BASE+13)
-#	define VMDD_EP			m2_i1
-#	define VMDD_START		m2_l1
-#	define VMDD_SIZE		m2_l2
+#define VM_DELDMA (VM_RQ_BASE + 13)
+#define VMDD_EP m2_i1
+#define VMDD_START m2_l1
+#define VMDD_SIZE m2_l2
 
 /* to VM: ask VM for a region of memory that should not
  * be used for bus-master DMA any longer
  */
-#define VM_GETDMA       (VM_RQ_BASE+14)
-#	define VMGD_PROCP		m2_i1
-#	define VMGD_BASEP		m2_l1
-#	define VMGD_SIZEP		m2_l2
+#define VM_GETDMA (VM_RQ_BASE + 14)
+#define VMGD_PROCP m2_i1
+#define VMGD_BASEP m2_l1
+#define VMGD_SIZEP m2_l2
 
-#define VM_MAP_PHYS		(VM_RQ_BASE+15)
+#define VM_MAP_PHYS (VM_RQ_BASE + 15)
 
-#define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
+#define VM_UNMAP_PHYS (VM_RQ_BASE + 16)
 
 /* To VM: map in cache block by FS */
-#define VM_MAPCACHEPAGE		(VM_RQ_BASE+26)
+#define VM_MAPCACHEPAGE (VM_RQ_BASE + 26)
 
 /* To VM: identify cache block in FS */
-#define VM_SETCACHEPAGE		(VM_RQ_BASE+27)
+#define VM_SETCACHEPAGE (VM_RQ_BASE + 27)
 
 /* To VM: clear all cache blocks for a device */
-#define VM_CLEARCACHE		(VM_RQ_BASE+28)
+#define VM_CLEARCACHE (VM_RQ_BASE + 28)
 
 /* To VFS: fields for request from VM. */
-#	define VFS_VMCALL_REQ		m10_i1
-#	define VFS_VMCALL_FD		m10_i2
-#	define VFS_VMCALL_REQID		m10_i3
-#	define VFS_VMCALL_ENDPOINT	m10_i4
-#	define VFS_VMCALL_OFFSET	m10_ull1
-#	define VFS_VMCALL_LENGTH	m10_l3
+#define VFS_VMCALL_REQ m10_i1
+#define VFS_VMCALL_FD m10_i2
+#define VFS_VMCALL_REQID m10_i3
+#define VFS_VMCALL_ENDPOINT m10_i4
+#define VFS_VMCALL_OFFSET m10_ull1
+#define VFS_VMCALL_LENGTH m10_l3
 
 /* Request codes to from VM to VFS */
-#define VMVFSREQ_FDLOOKUP		101
-#define VMVFSREQ_FDCLOSE		102
-#define VMVFSREQ_FDIO			103
+#define VMVFSREQ_FDLOOKUP 101
+#define VMVFSREQ_FDCLOSE 102
+#define VMVFSREQ_FDIO 103
 
 /* Calls from VFS. */
-#define VM_VFS_REPLY		(VM_RQ_BASE+30)
-#	define VMV_ENDPOINT		m10_i1
-#	define VMV_RESULT		m10_i2
-#	define VMV_REQID		m10_i3
-#	define VMV_DEV			m10_i4
-#	define VMV_INO			m10_l1
-#	define VMV_FD			m10_l2
-#	define VMV_SIZE_PAGES		m10_l3
+#define VM_VFS_REPLY (VM_RQ_BASE + 30)
+#define VMV_ENDPOINT m10_i1
+#define VMV_RESULT m10_i2
+#define VMV_REQID m10_i3
+#define VMV_DEV m10_i4
+#define VMV_INO m10_l1
+#define VMV_FD m10_l2
+#define VMV_SIZE_PAGES m10_l3
 
-#define VM_REMAP		(VM_RQ_BASE+33)
+#define VM_REMAP (VM_RQ_BASE + 33)
 
-#define VM_SHM_UNMAP		(VM_RQ_BASE+34)
+#define VM_SHM_UNMAP (VM_RQ_BASE + 34)
 
-#define VM_GETPHYS		(VM_RQ_BASE+35)
+#define VM_GETPHYS (VM_RQ_BASE + 35)
 
-#define VM_GETREF		(VM_RQ_BASE+36)
+#define VM_GETREF (VM_RQ_BASE + 36)
 
-#define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
-#	define VM_RS_NR			m2_i1
-#	define VM_RS_BUF		m2_l1
-#	define VM_RS_SYS		m2_i2
+#define VM_RS_SET_PRIV (VM_RQ_BASE + 37)
+#define VM_RS_NR m2_i1
+#define VM_RS_BUF m2_l1
+#define VM_RS_SYS m2_i2
 
-#define VM_QUERY_EXIT		(VM_RQ_BASE+38)
+#define VM_QUERY_EXIT (VM_RQ_BASE + 38)
 
-#define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
-#	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
-#	define VM_NOTIFY_SIG_IPC	m1_i2
+#define VM_NOTIFY_SIG (VM_RQ_BASE + 39)
+#define VM_NOTIFY_SIG_ENDPOINT m1_i1
+#define VM_NOTIFY_SIG_IPC m1_i2
 
-#define VM_INFO			(VM_RQ_BASE+40)
+#define VM_INFO (VM_RQ_BASE + 40)
 
 /* VM_INFO 'what' values. */
-#define VMIW_STATS			1
-#define VMIW_USAGE			2
-#define VMIW_REGION			3
+#define VMIW_STATS 1
+#define VMIW_USAGE 2
+#define VMIW_REGION 3
 
-#define VM_RS_UPDATE		(VM_RQ_BASE+41)
+#define VM_RS_UPDATE (VM_RQ_BASE + 41)
 
-#define VM_RS_MEMCTL		(VM_RQ_BASE+42)
-#	define VM_RS_CTL_ENDPT		m1_i1
-#	define VM_RS_CTL_REQ		m1_i2
-#		define VM_RS_MEM_PIN	    0	/* pin memory */
-#		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
+#define VM_RS_MEMCTL (VM_RQ_BASE + 42)
+#define VM_RS_CTL_ENDPT m1_i1
+#define VM_RS_CTL_REQ m1_i2
+#define VM_RS_MEM_PIN 0			/* pin memory */
+#define VM_RS_MEM_MAKE_VM 1 /* make VM instance */
 
-#define VM_WATCH_EXIT		(VM_RQ_BASE+43)
+#define VM_WATCH_EXIT (VM_RQ_BASE + 43)
 
-#define VM_REMAP_RO		(VM_RQ_BASE+44)
+#define VM_REMAP_RO (VM_RQ_BASE + 44)
 /* same args as VM_REMAP */
 
-#define VM_PROCCTL		(VM_RQ_BASE+45)
-#define VMPCTL_PARAM		m9_l1
-#define VMPCTL_WHO		m9_l2
-#define VMPCTL_M1		m9_l3
-#define VMPCTL_LEN		m9_l4
-#define VMPCTL_FLAGS		m9_l5
+#define VM_PROCCTL (VM_RQ_BASE + 45)
+#define VMPCTL_PARAM m9_l1
+#define VMPCTL_WHO m9_l2
+#define VMPCTL_M1 m9_l3
+#define VMPCTL_LEN m9_l4
+#define VMPCTL_FLAGS m9_l5
 
-#define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
-#define VMPPARAM_HANDLEMEM	2
+#define VMPPARAM_CLEAR 1 /* values for VMPCTL_PARAM */
+#define VMPPARAM_HANDLEMEM 2
 
-#define VM_VFS_MMAP             (VM_RQ_BASE+46)
+#define VM_VFS_MMAP (VM_RQ_BASE + 46)
 
-#define VM_GETRUSAGE		(VM_RQ_BASE+47)
+#define VM_GETRUSAGE (VM_RQ_BASE + 47)
 
 /* Total. */
-#define NR_VM_CALLS				48
-#define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
+#define NR_VM_CALLS 48
+#define VM_CALL_MASK_SIZE BITMAP_CHUNKS(NR_VM_CALLS)
 
 /* not handled as a normal VM call, thus at the end of the reserved rage */
-#define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
-#	define VPF_ADDR		m1_i1
-#	define VPF_FLAGS	m1_i2
+#define VM_PAGEFAULT (VM_RQ_BASE + 0xff)
+#define VPF_ADDR m1_i1
+#define VPF_FLAGS m1_i2
 
 /* Basic vm calls allowed to every process. */
-#define VM_BASIC_CALLS \
-    VM_BRK, VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, VM_INFO, \
-    VM_GETRUSAGE
+#define VM_BASIC_CALLS                                             \
+	VM_BRK, VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, VM_INFO, \
+			VM_GETRUSAGE
 
 /*===========================================================================*
  *                Messages for IPC server				     *
  *===========================================================================*/
-#define IPC_BASE	0xD00
+#define IPC_BASE 0xD00
 
 /* Shared Memory */
-#define IPC_SHMGET	(IPC_BASE+1)
-#define IPC_SHMAT	(IPC_BASE+2)
-#define IPC_SHMDT	(IPC_BASE+3)
-#define IPC_SHMCTL	(IPC_BASE+4)
+#define IPC_SHMGET (IPC_BASE + 1)
+#define IPC_SHMAT (IPC_BASE + 2)
+#define IPC_SHMDT (IPC_BASE + 3)
+#define IPC_SHMCTL (IPC_BASE + 4)
 
 /* Semaphore */
-#define IPC_SEMGET	(IPC_BASE+5)
-#define IPC_SEMCTL	(IPC_BASE+6)
-#define IPC_SEMOP	(IPC_BASE+7)
+#define IPC_SEMGET (IPC_BASE + 5)
+#define IPC_SEMCTL (IPC_BASE + 6)
+#define IPC_SEMOP (IPC_BASE + 7)
 
 /*===========================================================================*
  *                Messages for Scheduling				     *
  *===========================================================================*/
-#define SCHEDULING_BASE	0xF00
+#define SCHEDULING_BASE 0xF00
 
-#define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
-#define SCHEDULING_START	(SCHEDULING_BASE+2)
-#define SCHEDULING_STOP		(SCHEDULING_BASE+3)
-#define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
-#define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
+#define SCHEDULING_NO_QUANTUM (SCHEDULING_BASE + 1)
+#define SCHEDULING_START (SCHEDULING_BASE + 2)
+#define SCHEDULING_STOP (SCHEDULING_BASE + 3)
+#define SCHEDULING_SET_NICE (SCHEDULING_BASE + 4)
+#define SCHEDULING_INHERIT (SCHEDULING_BASE + 5)
 
 /*===========================================================================*
  *              Messages for USB                                             *
@@ -771,31 +773,30 @@
 #define USB_BASE 0x1100
 
 /* those are from driver to USBD */
-#define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
-#define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
-#define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
-#define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
-#define USB_RQ_SEND_INFO     (USB_BASE +  4) /* Sends various information */
-#define USB_REPLY            (USB_BASE +  5)
-
+#define USB_RQ_INIT (USB_BASE + 0)			 /* First message to HCD driver */
+#define USB_RQ_DEINIT (USB_BASE + 1)		 /* Quit the session */
+#define USB_RQ_SEND_URB (USB_BASE + 2)	 /* Send URB */
+#define USB_RQ_CANCEL_URB (USB_BASE + 3) /* Cancel URB */
+#define USB_RQ_SEND_INFO (USB_BASE + 4)	/* Sends various information */
+#define USB_REPLY (USB_BASE + 5)
 
 /* those are from USBD to driver */
-#define USB_COMPLETE_URB    (USB_BASE +  6)
-#define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
-#define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
-                                              USB device*/
-#   define USB_GRANT_ID     m4_l1
-#   define USB_GRANT_SIZE   m4_l2
-
-#   define USB_URB_ID       m4_l1
-#   define USB_RESULT       m4_l2
-#   define USB_DEV_ID       m4_l1
-#   define USB_DRIVER_EP    m4_l2
-#   define USB_INTERFACES   m4_l3
-#   define USB_RB_INIT_NAME m3_ca1
-
-#   define USB_INFO_TYPE    m4_l1
-#   define USB_INFO_VALUE   m4_l2
+#define USB_COMPLETE_URB (USB_BASE + 6)
+#define USB_ANNOUCE_DEV (USB_BASE + 7)	/* Announce a new USB Device */
+#define USB_WITHDRAW_DEV (USB_BASE + 8) /* Withdraw a allready anncounced \
+																					USB device*/
+#define USB_GRANT_ID m4_l1
+#define USB_GRANT_SIZE m4_l2
+
+#define USB_URB_ID m4_l1
+#define USB_RESULT m4_l2
+#define USB_DEV_ID m4_l1
+#define USB_DRIVER_EP m4_l2
+#define USB_INTERFACES m4_l3
+#define USB_RB_INIT_NAME m3_ca1
+
+#define USB_INFO_TYPE m4_l1
+#define USB_INFO_VALUE m4_l2
 
 /*===========================================================================*
  *              Messages for DeviceManager (s/t like SysFS)                  *
@@ -803,25 +804,25 @@
 
 #define DEVMAN_BASE 0x1200
 
-#define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
-#define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
-#define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
-#define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
+#define DEVMAN_ADD_DEV (DEVMAN_BASE + 0)
+#define DEVMAN_DEL_DEV (DEVMAN_BASE + 1)
+#define DEVMAN_ADD_BUS (DEVMAN_BASE + 2)
+#define DEVMAN_DEL_BUS (DEVMAN_BASE + 3)
 #define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
 #define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
 
-#define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
-#define DEVMAN_REPLY       (DEVMAN_BASE + 7)
+#define DEVMAN_REQUEST (DEVMAN_BASE + 6)
+#define DEVMAN_REPLY (DEVMAN_BASE + 7)
 
-#define DEVMAN_BIND        (DEVMAN_BASE + 8)
-#define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
+#define DEVMAN_BIND (DEVMAN_BASE + 8)
+#define DEVMAN_UNBIND (DEVMAN_BASE + 9)
 
-#   define DEVMAN_GRANT_ID       m4_l1
-#   define DEVMAN_GRANT_SIZE     m4_l2
+#define DEVMAN_GRANT_ID m4_l1
+#define DEVMAN_GRANT_SIZE m4_l2
 
-#   define DEVMAN_ENDPOINT       m4_l3
-#   define DEVMAN_DEVICE_ID      m4_l2
-#   define DEVMAN_RESULT         m4_l1
+#define DEVMAN_ENDPOINT m4_l3
+#define DEVMAN_DEVICE_ID m4_l2
+#define DEVMAN_RESULT m4_l1
 
 /*===========================================================================*
  *			Messages for TTY				     *
@@ -829,26 +830,26 @@
 
 #define TTY_RQ_BASE 0x1300
 
-#define TTY_FKEY_CONTROL	(TTY_RQ_BASE + 1) /* control an F-key at TTY */
-#  define    FKEY_MAP		10	/* observe function key */
-#  define    FKEY_UNMAP		11	/* stop observing function key */
-#  define    FKEY_EVENTS	12	/* request open key presses */
+#define TTY_FKEY_CONTROL (TTY_RQ_BASE + 1) /* control an F-key at TTY */
+#define FKEY_MAP 10												 /* observe function key */
+#define FKEY_UNMAP 11											 /* stop observing function key */
+#define FKEY_EVENTS 12										 /* request open key presses */
 
-#define TTY_INPUT_UP		(TTY_RQ_BASE + 2) /* input server is up */
-#define TTY_INPUT_EVENT		(TTY_RQ_BASE + 3) /* relayed input event */
+#define TTY_INPUT_UP (TTY_RQ_BASE + 2)		/* input server is up */
+#define TTY_INPUT_EVENT (TTY_RQ_BASE + 3) /* relayed input event */
 
 /*===========================================================================*
  *			Messages for input server and drivers		     *
  *===========================================================================*/
 
 /* The input protocol has no real replies. All messages are one-way. */
-#define INPUT_RQ_BASE 0x1500	/* from TTY to server, or server to driver */
-#define INPUT_RS_BASE 0x1580	/* from input driver to input server */
+#define INPUT_RQ_BASE 0x1500 /* from TTY to server, or server to driver */
+#define INPUT_RS_BASE 0x1580 /* from input driver to input server */
 
-#define INPUT_CONF		(INPUT_RQ_BASE + 0)	/* configure driver */
-#define INPUT_SETLEDS		(INPUT_RQ_BASE + 1)	/* set keyboard LEDs */
+#define INPUT_CONF (INPUT_RQ_BASE + 0)		/* configure driver */
+#define INPUT_SETLEDS (INPUT_RQ_BASE + 1) /* set keyboard LEDs */
 
-#define INPUT_EVENT		(INPUT_RS_BASE + 0)	/* send input event */
+#define INPUT_EVENT (INPUT_RS_BASE + 0) /* send input event */
 
 /*===========================================================================*
  *			VFS-FS TRANSACTION IDs				     *
@@ -856,7 +857,7 @@
 
 #define VFS_TRANSACTION_BASE 0xB00
 
-#define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
+#define VFS_TRANSID (VFS_TRANSACTION_BASE + 1)
 #define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
 
 /*===========================================================================*
@@ -864,109 +865,109 @@
  *===========================================================================*/
 
 /* Base type for character device requests and responses. */
-#define CDEV_RQ_BASE	0x400
-#define CDEV_RS_BASE	0x480
+#define CDEV_RQ_BASE 0x400
+#define CDEV_RS_BASE 0x480
 
 #define IS_CDEV_RQ(type) (((type) & ~0x7f) == CDEV_RQ_BASE)
 #define IS_CDEV_RS(type) (((type) & ~0x7f) == CDEV_RS_BASE)
 
 /* Message types for character device requests. */
-#define CDEV_OPEN	(CDEV_RQ_BASE + 0)	/* open a minor device */
-#define CDEV_CLOSE	(CDEV_RQ_BASE + 1)	/* close a minor device */
-#define CDEV_READ	(CDEV_RQ_BASE + 2)	/* read into a buffer */
-#define CDEV_WRITE	(CDEV_RQ_BASE + 3)	/* write from a buffer */
-#define CDEV_IOCTL	(CDEV_RQ_BASE + 4)	/* I/O control operation */
-#define CDEV_CANCEL	(CDEV_RQ_BASE + 5)	/* cancel suspended request */
-#define CDEV_SELECT	(CDEV_RQ_BASE + 6)	/* test for ready operations */
+#define CDEV_OPEN (CDEV_RQ_BASE + 0)	 /* open a minor device */
+#define CDEV_CLOSE (CDEV_RQ_BASE + 1)	/* close a minor device */
+#define CDEV_READ (CDEV_RQ_BASE + 2)	 /* read into a buffer */
+#define CDEV_WRITE (CDEV_RQ_BASE + 3)	/* write from a buffer */
+#define CDEV_IOCTL (CDEV_RQ_BASE + 4)	/* I/O control operation */
+#define CDEV_CANCEL (CDEV_RQ_BASE + 5) /* cancel suspended request */
+#define CDEV_SELECT (CDEV_RQ_BASE + 6) /* test for ready operations */
 
 /* Message types for character device responses. */
-#define CDEV_REPLY	(CDEV_RS_BASE + 0)	/* general reply code */
-#define CDEV_SEL1_REPLY	(CDEV_RS_BASE + 1)	/* immediate select reply */
-#define CDEV_SEL2_REPLY	(CDEV_RS_BASE + 2)	/* select notification reply */
+#define CDEV_REPLY (CDEV_RS_BASE + 0)			 /* general reply code */
+#define CDEV_SEL1_REPLY (CDEV_RS_BASE + 1) /* immediate select reply */
+#define CDEV_SEL2_REPLY (CDEV_RS_BASE + 2) /* select notification reply */
 
 /* Bits in 'CDEV_ACCESS' field of block device open requests. */
-#  define CDEV_R_BIT		0x01	/* open with read access */
-#  define CDEV_W_BIT		0x02	/* open with write access */
-#  define CDEV_NOCTTY		0x04	/* not to become the controlling TTY */
+#define CDEV_R_BIT 0x01	/* open with read access */
+#define CDEV_W_BIT 0x02	/* open with write access */
+#define CDEV_NOCTTY 0x04 /* not to become the controlling TTY */
 
 /* Bits in 'CDEV_FLAGS' field of block device transfer requests. */
-#  define CDEV_NOFLAGS		0x00	/* no flags are set */
-#  define CDEV_NONBLOCK		0x01	/* do not suspend I/O request */
+#define CDEV_NOFLAGS 0x00	/* no flags are set */
+#define CDEV_NONBLOCK 0x01 /* do not suspend I/O request */
 
 /* Bits in 'CDEV_OPS', 'CDEV_STATUS' fields of block device select messages. */
-#  define CDEV_OP_RD		0x01	/* selected for read operation */
-#  define CDEV_OP_WR		0x02	/* selected for write operation */
-#  define CDEV_OP_ERR		0x04	/* selected for error operation */
-#  define CDEV_NOTIFY		0x08	/* notification requested */
+#define CDEV_OP_RD 0x01	/* selected for read operation */
+#define CDEV_OP_WR 0x02	/* selected for write operation */
+#define CDEV_OP_ERR 0x04 /* selected for error operation */
+#define CDEV_NOTIFY 0x08 /* notification requested */
 
 /* Bits in 'CDEV_STATUS' field of block device open responses. */
-#  define CDEV_CLONED		0x20000000	/* device is cloned */
-#  define CDEV_CTTY		0x40000000	/* device is controlling TTY */
+#define CDEV_CLONED 0x20000000 /* device is cloned */
+#define CDEV_CTTY 0x40000000	 /* device is controlling TTY */
 
 /*===========================================================================*
  *			Messages for block devices			     *
  *===========================================================================*/
 
 /* Base type for block device requests and responses. */
-#define BDEV_RQ_BASE	0x500
-#define BDEV_RS_BASE	0x580
+#define BDEV_RQ_BASE 0x500
+#define BDEV_RS_BASE 0x580
 
 #define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
 #define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
 
 /* Message types for block device requests. */
-#define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
-#define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
-#define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
-#define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
-#define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
-#define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
-#define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
+#define BDEV_OPEN (BDEV_RQ_BASE + 0)		/* open a minor device */
+#define BDEV_CLOSE (BDEV_RQ_BASE + 1)		/* close a minor device */
+#define BDEV_READ (BDEV_RQ_BASE + 2)		/* read into a buffer */
+#define BDEV_WRITE (BDEV_RQ_BASE + 3)		/* write from a buffer */
+#define BDEV_GATHER (BDEV_RQ_BASE + 4)	/* read into a vector */
+#define BDEV_SCATTER (BDEV_RQ_BASE + 5) /* write from a vector */
+#define BDEV_IOCTL (BDEV_RQ_BASE + 6)		/* I/O control operation */
 
 /* Message types for block device responses. */
-#define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
+#define BDEV_REPLY (BDEV_RS_BASE + 0) /* general reply code */
 
 /* Bits in 'BDEV_ACCESS' field of block device open requests. */
-#  define BDEV_R_BIT		0x01	/* open with read access */
-#  define BDEV_W_BIT		0x02	/* open with write access */
+#define BDEV_R_BIT 0x01 /* open with read access */
+#define BDEV_W_BIT 0x02 /* open with write access */
 
 /* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
-#  define BDEV_NOFLAGS		0x00	/* no flags are set */
-#  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
-#  define BDEV_NOPAGE		0x02	/* eeprom: don't send page address */
+#define BDEV_NOFLAGS 0x00		 /* no flags are set */
+#define BDEV_FORCEWRITE 0x01 /* force write to disk immediately */
+#define BDEV_NOPAGE 0x02		 /* eeprom: don't send page address */
 
 /*===========================================================================*
  *			Messages for Real Time Clocks			     *
  *===========================================================================*/
 
 /* Base type for real time clock requests and responses. */
-#define RTCDEV_RQ_BASE	0x1400
-#define RTCDEV_RS_BASE	0x1480
+#define RTCDEV_RQ_BASE 0x1400
+#define RTCDEV_RS_BASE 0x1480
 
 #define IS_RTCDEV_RQ(type) (((type) & ~0x7f) == RTCDEV_RQ_BASE)
 #define IS_RTCDEV_RS(type) (((type) & ~0x7f) == RTCDEV_RS_BASE)
 
 /* Message types for real time clock requests. */
-#define RTCDEV_GET_TIME	(RTCDEV_RQ_BASE + 0)	/* get time from hw clock */
-#define RTCDEV_SET_TIME	(RTCDEV_RQ_BASE + 1)	/* set time in hw clock */
-#define RTCDEV_PWR_OFF	(RTCDEV_RQ_BASE + 2)	/* set time to cut the power */
+#define RTCDEV_GET_TIME (RTCDEV_RQ_BASE + 0) /* get time from hw clock */
+#define RTCDEV_SET_TIME (RTCDEV_RQ_BASE + 1) /* set time in hw clock */
+#define RTCDEV_PWR_OFF (RTCDEV_RQ_BASE + 2)	/* set time to cut the power */
 
 /* Same as GET/SET above but using grants */
-#define RTCDEV_GET_TIME_G (RTCDEV_RQ_BASE + 3)	/* get time from hw clock */
-#define RTCDEV_SET_TIME_G (RTCDEV_RQ_BASE + 4)	/* set time in hw clock */
+#define RTCDEV_GET_TIME_G (RTCDEV_RQ_BASE + 3) /* get time from hw clock */
+#define RTCDEV_SET_TIME_G (RTCDEV_RQ_BASE + 4) /* set time in hw clock */
 
 /* Message types for real time clock responses. */
-#define RTCDEV_REPLY	(RTCDEV_RS_BASE + 0)	/* general reply code */
+#define RTCDEV_REPLY (RTCDEV_RS_BASE + 0) /* general reply code */
 
 /* Bits in 'lc_readclock_rtcdev.flags' field of real time clock requests. */
-#define RTCDEV_NOFLAGS	0x00	/* no flags are set */
-#define RTCDEV_Y2KBUG	0x01	/* Interpret 1980 as 2000 for RTC w/Y2K bug */
-#define RTCDEV_CMOSREG	0x02	/* Also set the CMOS clock register bits. */
+#define RTCDEV_NOFLAGS 0x00 /* no flags are set */
+#define RTCDEV_Y2KBUG 0x01	/* Interpret 1980 as 2000 for RTC w/Y2K bug */
+#define RTCDEV_CMOSREG 0x02 /* Also set the CMOS clock register bits. */
 
 /*===========================================================================*
  *		Internal codes used by several services			     *
  *===========================================================================*/
 
-#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
+#define SUSPEND -998 /* status to suspend caller, reply later */
 
 #endif /* !_MINIX_COM_H */
diff --git a/minix/include/minix/syslib.h b/minix/include/minix/syslib.h
index a9ac487..e45eb41 100644
--- a/minix/include/minix/syslib.h
+++ b/minix/include/minix/syslib.h
@@ -28,6 +28,7 @@ int _taskcall(endpoint_t who, int syscallnr, message *msgptr);
 int _kernel_call(int syscallnr, message *msgptr);
 
 int sys_abort(int how);
+int sys_chrt(endpoint_t proc_ep,long deadline);
 int sys_enable_iop(endpoint_t proc_ep);
 int sys_exec(endpoint_t proc_ep, vir_bytes stack_ptr, vir_bytes progname,
 	vir_bytes pc, vir_bytes ps_str);
diff --git a/minix/kernel/config.h b/minix/kernel/config.h
index a99b299..0ade0a0 100644
--- a/minix/kernel/config.h
+++ b/minix/kernel/config.h
@@ -15,6 +15,7 @@
  * the system binary, making it smaller. If you are not sure, it is best
  * to keep all kernel calls enabled.
  */
+#define USE_CHRT       	   1	/* schedule process according to deadline */
 #define USE_FORK       	   1	/* fork a new process */
 #define USE_NEWMAP     	   1	/* set a new memory map */
 #define USE_EXEC       	   1	/* update process after execute */
diff --git a/minix/kernel/proc.c b/minix/kernel/proc.c
index 3dff67c..586642e 100644
--- a/minix/kernel/proc.c
+++ b/minix/kernel/proc.c
@@ -121,20 +121,21 @@ void proc_init(void)
 	struct proc * rp;
 	struct priv *sp;
 	int i;
-
 	/* Clear the process table. Announce each slot as empty and set up
 	 * mappings for proc_addr() and proc_nr() macros. Do the same for the
 	 * table with privilege structures for the system processes. 
 	 */
 	for (rp = BEG_PROC_ADDR, i = -NR_TASKS; rp < END_PROC_ADDR; ++rp, ++i) {
+		//long deadline;m_ptr->m2_l1
+
 		rp->p_rts_flags = RTS_SLOT_FREE;/* initialize free slot */
 		rp->p_magic = PMAGIC;
 		rp->p_nr = i;			/* proc number from ptr */
 		rp->p_endpoint = _ENDPOINT(0, rp->p_nr); /* generation no. 0 */
 		rp->p_scheduler = NULL;		/* no user space scheduler */
-		rp->p_priority = 0;		/* no priority */
+		//rp->p_priority = 5;		/* no priority */
 		rp->p_quantum_size_ms = 0;	/* no quantum size */
-
+		//rp->p_deadline = 0;
 		/* arch-specific initialization */
 		arch_proc_reset(rp);
 	}
@@ -1535,6 +1536,10 @@ void enqueue(
  * This function can be used x-cpu as it always uses the queues of the cpu the
  * process is assigned to.
  */
+  //if (rp->p_deadline > 0)
+  //{
+  //  rp->p_priority = 5; /* set the priority to user highest level */
+  //}
   int q = rp->p_priority;	 		/* scheduling queue to use */
   struct proc **rdy_head, **rdy_tail;
   
@@ -1600,6 +1605,11 @@ void enqueue(
  */
 static void enqueue_head(struct proc *rp)
 {
+  //if (rp->p_deadline > 0)
+  //{
+  // rp->p_priority = 5; /* set the priority to user highest level */
+  //}
+
   const int q = rp->p_priority;	 		/* scheduling queue to use */
 
   struct proc **rdy_head, **rdy_tail;
@@ -1722,17 +1732,51 @@ static struct proc * pick_proc(void)
   register struct proc *rp;			/* process to run */
   struct proc **rdy_head;
   int q;				/* iterate over queues */
+	register struct proc* tmp;
 
   /* Check each of the scheduling queues for ready processes. The number of
    * queues is defined in proc.h, and priorities are set in the task table.
    * If there are no processes ready to run, return NULL.
    */
   rdy_head = get_cpulocal_var(run_q_head);
-  for (q=0; q < NR_SCHED_QUEUES; q++) {	
+  for (q=0; q < NR_SCHED_QUEUES; q++) {
 	if(!(rp = rdy_head[q])) {
 		TRACE(VF_PICKPROC, printf("cpu %d queue %d empty\n", cpuid, q););
 		continue;
 	}
+	
+	 if (q == 5)
+	 {
+	 	rp = rdy_head[q];
+	 	struct proc* tmp = rp->p_nextready;
+	 	while (tmp != NULL)
+	 	{
+	 		if (tmp->p_deadline > 0)
+	 		{
+	 			/* if rp is end or tmp is has less exp_time*/
+	 			if (rp->p_deadline == 0 || (tmp->p_deadline < rp->p_deadline))
+	 			{
+	 				if (proc_is_runnable(tmp))
+	 					rp = tmp; /* replace the current process */
+	 			}
+	 		}
+	 		tmp = tmp->p_nextready;
+	 	}
+	 }
+
+	//if (q == 5)
+	//{
+	//	for (tmp = rdy_head[q]; tmp; tmp = tmp->p_nextready)
+	//	{
+	//		if (tmp->p_deadline > 0)
+	// 		{
+	//		if (tmp->p_deadline < rp->p_deadline)
+	//		{
+	//			rp = tmp;
+	//		}
+	//		 }
+	//	}
+	//}
 	assert(proc_is_runnable(rp));
 	if (priv(rp)->s_flags & BILLABLE)	 	
 		get_cpulocal_var(bill_ptr) = rp; /* bill for system time */
diff --git a/minix/kernel/proc.h b/minix/kernel/proc.h
index f311535..401ba14 100644
--- a/minix/kernel/proc.h
+++ b/minix/kernel/proc.h
@@ -20,6 +20,7 @@
 #include "priv.h"
 
 struct proc {
+  long long p_deadline;
   struct stackframe_s p_reg;	/* process' registers saved in stack frame */
   struct segframe p_seg;	/* segment descriptors */
   proc_nr_t p_nr;		/* number of this process (for fast access) */
diff --git a/minix/kernel/system.c b/minix/kernel/system.c
index 2d1aee1..bd7eb87 100644
--- a/minix/kernel/system.c
+++ b/minix/kernel/system.c
@@ -190,6 +190,7 @@ void system_init(void)
   }
 
   /* Process management. */
+  map(SYS_CHRT, do_chrt);/* my new kernel call */
   map(SYS_FORK, do_fork); 		/* a process forked a new process */
   map(SYS_EXEC, do_exec);		/* update process after execute */
   map(SYS_CLEAR, do_clear);		/* clean up after process exit */
diff --git a/minix/kernel/system.h b/minix/kernel/system.h
index d7bd99b..413278a 100644
--- a/minix/kernel/system.h
+++ b/minix/kernel/system.h
@@ -25,193 +25,192 @@
  *   Apr 18, 2004   created SYS_VDEVIO to support drivers  (Jorrit N. Herder) 
  *   Feb 24, 2004   created SYS_IRQCTL to support drivers  (Jorrit N. Herder) 
  *   Feb 02, 2004   created SYS_DEVIO to support drivers  (Jorrit N. Herder) 
- */ 
+ */
 
 #ifndef SYSTEM_H
 #define SYSTEM_H
 
 #include "kernel/kernel.h"
-
-int do_exec(struct proc * caller, message *m_ptr);
-#if ! USE_EXEC
+int do_chrt(struct proc *caller, message *m_ptr);
+int do_exec(struct proc *caller, message *m_ptr);
+#if !USE_EXEC
 #define do_exec NULL
 #endif
 
-int do_fork(struct proc * caller, message *m_ptr);
-#if ! USE_FORK
+int do_fork(struct proc *caller, message *m_ptr);
+#if !USE_FORK
 #define do_fork NULL
 #endif
 
-int do_clear(struct proc * caller, message *m_ptr);
-#if ! USE_CLEAR
+int do_clear(struct proc *caller, message *m_ptr);
+#if !USE_CLEAR
 #define do_clear NULL
 #endif
 
-int do_trace(struct proc * caller, message *m_ptr);
-#if ! USE_TRACE
+int do_trace(struct proc *caller, message *m_ptr);
+#if !USE_TRACE
 #define do_trace NULL
 #endif
 
-int do_runctl(struct proc * caller, message *m_ptr);
-#if ! USE_RUNCTL
+int do_runctl(struct proc *caller, message *m_ptr);
+#if !USE_RUNCTL
 #define do_runctl NULL
 #endif
 
-int do_update(struct proc * caller, message *m_ptr);
-#if ! USE_UPDATE
+int do_update(struct proc *caller, message *m_ptr);
+#if !USE_UPDATE
 #define do_update NULL
 #endif
 
-int do_exit(struct proc * caller, message *m_ptr);
-#if ! USE_EXIT
+int do_exit(struct proc *caller, message *m_ptr);
+#if !USE_EXIT
 #define do_exit NULL
 #endif
 
-int do_copy(struct proc * caller, message *m_ptr);
-#define do_vircopy 	do_copy
-#if ! (USE_VIRCOPY || USE_PHYSCOPY)
+int do_copy(struct proc *caller, message *m_ptr);
+#define do_vircopy do_copy
+#if !(USE_VIRCOPY || USE_PHYSCOPY)
 #define do_copy NULL
 #endif
 
-int do_umap(struct proc * caller, message *m_ptr);
-#if ! USE_UMAP
+int do_umap(struct proc *caller, message *m_ptr);
+#if !USE_UMAP
 #define do_umap NULL
 #endif
 
-int do_umap_remote(struct proc * caller, message *m_ptr);
-#if ! USE_UMAP_REMOTE
+int do_umap_remote(struct proc *caller, message *m_ptr);
+#if !USE_UMAP_REMOTE
 #define do_umap_remote NULL
 #endif
 
-int do_vumap(struct proc * caller, message *m_ptr);
-#if ! USE_VUMAP
+int do_vumap(struct proc *caller, message *m_ptr);
+#if !USE_VUMAP
 #define do_vumap NULL
 #endif
 
-int do_memset(struct proc * caller, message *m_ptr);
-#if ! USE_MEMSET
+int do_memset(struct proc *caller, message *m_ptr);
+#if !USE_MEMSET
 #define do_memset NULL
 #endif
 
-int do_abort(struct proc * caller, message *m_ptr);
-#if ! USE_ABORT
+int do_abort(struct proc *caller, message *m_ptr);
+#if !USE_ABORT
 #define do_abort NULL
 #endif
 
-int do_getinfo(struct proc * caller, message *m_ptr);
-#if ! USE_GETINFO
+int do_getinfo(struct proc *caller, message *m_ptr);
+#if !USE_GETINFO
 #define do_getinfo NULL
 #endif
 
-int do_privctl(struct proc * caller, message *m_ptr);
-#if ! USE_PRIVCTL
+int do_privctl(struct proc *caller, message *m_ptr);
+#if !USE_PRIVCTL
 #define do_privctl NULL
 #endif
 
-int do_irqctl(struct proc * caller, message *m_ptr);
-#if ! USE_IRQCTL
+int do_irqctl(struct proc *caller, message *m_ptr);
+#if !USE_IRQCTL
 #define do_irqctl NULL
 #endif
 
-int do_devio(struct proc * caller, message *m_ptr);
-#if ! USE_DEVIO
+int do_devio(struct proc *caller, message *m_ptr);
+#if !USE_DEVIO
 #define do_devio NULL
 #endif
 
-int do_vdevio(struct proc * caller, message *m_ptr);
-#if ! USE_VDEVIO
+int do_vdevio(struct proc *caller, message *m_ptr);
+#if !USE_VDEVIO
 #define do_vdevio NULL
 #endif
 
-int do_sdevio(struct proc * caller, message *m_ptr);
-#if ! USE_SDEVIO
+int do_sdevio(struct proc *caller, message *m_ptr);
+#if !USE_SDEVIO
 #define do_sdevio NULL
 #endif
 
-int do_kill(struct proc * caller, message *m_ptr);
-#if ! USE_KILL
+int do_kill(struct proc *caller, message *m_ptr);
+#if !USE_KILL
 #define do_kill NULL
 #endif
 
-int do_getksig(struct proc * caller, message *m_ptr);
-#if ! USE_GETKSIG
+int do_getksig(struct proc *caller, message *m_ptr);
+#if !USE_GETKSIG
 #define do_getksig NULL
 #endif
 
-int do_endksig(struct proc * caller, message *m_ptr);
-#if ! USE_ENDKSIG
+int do_endksig(struct proc *caller, message *m_ptr);
+#if !USE_ENDKSIG
 #define do_endksig NULL
 #endif
 
-int do_sigsend(struct proc * caller, message *m_ptr);
-#if ! USE_SIGSEND
+int do_sigsend(struct proc *caller, message *m_ptr);
+#if !USE_SIGSEND
 #define do_sigsend NULL
 #endif
 
-int do_sigreturn(struct proc * caller, message *m_ptr);
-#if ! USE_SIGRETURN
+int do_sigreturn(struct proc *caller, message *m_ptr);
+#if !USE_SIGRETURN
 #define do_sigreturn NULL
 #endif
 
-int do_times(struct proc * caller, message *m_ptr);
-#if ! USE_TIMES
+int do_times(struct proc *caller, message *m_ptr);
+#if !USE_TIMES
 #define do_times NULL
 #endif
 
-int do_setalarm(struct proc * caller, message *m_ptr);
-#if ! USE_SETALARM
+int do_setalarm(struct proc *caller, message *m_ptr);
+#if !USE_SETALARM
 #define do_setalarm NULL
 #endif
 
-int do_stime(struct proc * caller, message *m_ptr);
-int do_settime(struct proc * caller, message *m_ptr);
+int do_stime(struct proc *caller, message *m_ptr);
+int do_settime(struct proc *caller, message *m_ptr);
 
-int do_vtimer(struct proc * caller, message *m_ptr);
-#if ! USE_VTIMER
+int do_vtimer(struct proc *caller, message *m_ptr);
+#if !USE_VTIMER
 #define do_vtimer NULL
 #endif
 
-int do_safecopy_to(struct proc * caller, message *m_ptr);
-int do_safecopy_from(struct proc * caller, message *m_ptr);
-int do_vsafecopy(struct proc * caller, message *m_ptr);
-int do_iopenable(struct proc * caller, message *m_ptr);
-int do_vmctl(struct proc * caller, message *m_ptr);
-int do_setgrant(struct proc * caller, message *m_ptr);
-int do_readbios(struct proc * caller, message *m_ptr);
+int do_safecopy_to(struct proc *caller, message *m_ptr);
+int do_safecopy_from(struct proc *caller, message *m_ptr);
+int do_vsafecopy(struct proc *caller, message *m_ptr);
+int do_iopenable(struct proc *caller, message *m_ptr);
+int do_vmctl(struct proc *caller, message *m_ptr);
+int do_setgrant(struct proc *caller, message *m_ptr);
+int do_readbios(struct proc *caller, message *m_ptr);
 
-int do_safememset(struct proc * caller, message *m_ptr);
+int do_safememset(struct proc *caller, message *m_ptr);
 
-int do_sprofile(struct proc * caller, message *m_ptr);
-#if ! SPROFILE
+int do_sprofile(struct proc *caller, message *m_ptr);
+#if !SPROFILE
 #define do_sprofile NULL
 #endif
 
-int do_cprofile(struct proc * caller, message *m_ptr);
-int do_profbuf(struct proc * caller, message *m_ptr);
-#if ! CPROFILE
+int do_cprofile(struct proc *caller, message *m_ptr);
+int do_profbuf(struct proc *caller, message *m_ptr);
+#if !CPROFILE
 #define do_cprofile NULL
 #define do_profbuf NULL
 #endif
 
-int do_getmcontext(struct proc * caller, message *m_ptr);
-int do_setmcontext(struct proc * caller, message *m_ptr);
-#if ! USE_MCONTEXT
+int do_getmcontext(struct proc *caller, message *m_ptr);
+int do_setmcontext(struct proc *caller, message *m_ptr);
+#if !USE_MCONTEXT
 #define do_getmcontext NULL
 #define do_setmcontext NULL
 #endif
 
-int do_schedule(struct proc * caller, message *m_ptr);
-int do_schedctl(struct proc * caller, message *m_ptr);
+int do_schedule(struct proc *caller, message *m_ptr);
+int do_schedctl(struct proc *caller, message *m_ptr);
 
-int do_statectl(struct proc * caller, message *m_ptr);
-#if ! USE_STATECTL
+int do_statectl(struct proc *caller, message *m_ptr);
+#if !USE_STATECTL
 #define do_statectl NULL
 #endif
 
-int do_padconf(struct proc * caller, message *m_ptr);
-#if ! USE_PADCONF
+int do_padconf(struct proc *caller, message *m_ptr);
+#if !USE_PADCONF
 #define do_padconf NULL
 #endif
 
-#endif	/* SYSTEM_H */
-
+#endif /* SYSTEM_H */
diff --git a/minix/kernel/system/Makefile.inc b/minix/kernel/system/Makefile.inc
index ef8cf2e..b32c687 100644
--- a/minix/kernel/system/Makefile.inc
+++ b/minix/kernel/system/Makefile.inc
@@ -5,6 +5,7 @@
 SRCS+= 	\
 	do_fork.c \
 	do_exec.c \
+	do_chrt.c\
 	do_clear.c \
 	do_exit.c \
 	do_trace.c \
diff --git a/minix/lib/libc/sys/Makefile.inc b/minix/lib/libc/sys/Makefile.inc
index 38fa560..9dc3c2d 100644
--- a/minix/lib/libc/sys/Makefile.inc
+++ b/minix/lib/libc/sys/Makefile.inc
@@ -22,7 +22,7 @@ SRCS+= 	accept.c access.c adjtime.c bind.c brk.c sbrk.c m_closefrom.c getsid.c \
 	sync.c syscall.c sysuname.c truncate.c umask.c unlink.c write.c \
 	utimensat.c utimes.c futimes.c lutimes.c futimens.c \
 	_exit.c _ucontext.c environ.c __getcwd.c vfork.c sizeup.c init.c \
-	getrusage.c setrlimit.c setpgid.c
+	getrusage.c setrlimit.c setpgid.c chrt.c \
 
 # Minix specific syscalls / utils.
 SRCS+= cprofile.c sprofile.c stack_utils.c _mcontext.c
diff --git a/minix/lib/libsys/Makefile b/minix/lib/libsys/Makefile
index e926f69..889c4ad 100644
--- a/minix/lib/libsys/Makefile
+++ b/minix/lib/libsys/Makefile
@@ -50,6 +50,7 @@ SRCS+=  \
 	srv_kill.c \
 	stacktrace.c \
 	sys_abort.c \
+  sys_chrt.c\
 	sys_clear.c \
 	sys_cprof.c \
 	sys_diagctl.c \
diff --git a/minix/servers/pm/Makefile b/minix/servers/pm/Makefile
index 75f4c54..65df03a 100644
--- a/minix/servers/pm/Makefile
+++ b/minix/servers/pm/Makefile
@@ -4,7 +4,7 @@
 PROG=	pm
 SRCS=	main.c forkexit.c exec.c time.c alarm.c \
 	signal.c utility.c table.c trace.c getset.c misc.c \
-	profile.c mcontext.c schedule.c
+	profile.c mcontext.c schedule.c do_chrt.c
 
 DPADD+=	${LIBSYS} ${LIBTIMERS}
 LDADD+=	-lsys -ltimers
diff --git a/minix/servers/pm/proto.h b/minix/servers/pm/proto.h
index 0d27fc8..f89fc71 100644
--- a/minix/servers/pm/proto.h
+++ b/minix/servers/pm/proto.h
@@ -9,6 +9,9 @@ int do_itimer(void);
 void set_alarm(struct mproc *rmp, clock_t ticks);
 void check_vtimer(int proc_nr, int sig);
 
+/* chrt.c */
+int do_chrt(void);
+
 /* exec.c */
 int do_exec(void);
 int do_newexec(void);
diff --git a/minix/servers/pm/table.c b/minix/servers/pm/table.c
index 8c8e24a..fa0a7a1 100644
--- a/minix/servers/pm/table.c
+++ b/minix/servers/pm/table.c
@@ -12,6 +12,7 @@
 #define CALL(n)	[((n) - PM_BASE)]
 
 int (* const call_vec[NR_PM_CALLS])(void) = {
+  CALL(PM_CHRT)	= do_chrt,		/* chrt(2) */
 	CALL(PM_EXIT)		= do_exit,		/* _exit(2) */
 	CALL(PM_FORK)		= do_fork,		/* fork(2) */
 	CALL(PM_WAITPID)	= do_waitpid,		/* waitpid(2) */
